<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Forces & Equilibrium Analyzer | Mechanics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --primary: #0f766e;
            --primary-light: #14b8a6;
            --primary-dark: #115e59;
            --surface: #f0fdfa;
            --card-bg: #ffffff;
            --text-main: #334155;
            --text-light: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --input-bg: #ffffff;
            --text-on-primary: #ffffff;
            --grid-line: #e2e8f0;
            --grid-bg: #f0fdfa;
            /* P4 used surface color originally */
        }

        [data-theme="dark"] {
            --primary: #2dd4bf;
            --primary-light: #5eead4;
            --primary-dark: #14b8a6;
            --surface: #0f172a;
            --card-bg: #1e293b;
            --text-main: #f1f5f9;
            --text-light: #94a3b8;
            --border: #334155;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --input-bg: #0f172a;
            --text-on-primary: #1e293b;
            --grid-line: #334155;
            --grid-bg: #0f172a;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--surface);
            color: var(--text-main);
            margin: 0;
            padding: 40px 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            color: var(--primary-dark);
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
        }

        .subtitle {
            color: var(--text-light);
            font-size: 1.1rem;
            margin-top: 10px;
        }

        .grid {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
            align-items: start;
        }

        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
        }

        .card-header {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid var(--surface);
            padding-bottom: 12px;
        }

        .form-group {
            margin-bottom: 14px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 5px;
            color: var(--text-main);
        }

        input[type="number"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.85rem;
            font-family: 'Inter', sans-serif;
            box-sizing: border-box;
            transition: border-color 0.2s;
            background-color: var(--input-bg);
            color: var(--text-main);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        button {
            width: 100%;
            padding: 9px 14px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 6px;
        }

        button:hover {
            background-color: var(--primary-light);
        }

        button:active {
            background-color: var(--primary-dark);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: var(--grid-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 24px;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info-section {
            background-color: var(--surface);
            border-left: 4px solid var(--primary);
            padding: 14px;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        .info-section h3 {
            margin: 0 0 8px 0;
            font-size: 0.9rem;
            color: var(--primary-dark);
            font-weight: 600;
        }

        .info-section p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.5;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 12px 0;
        }

        .result-item {
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        .result-item strong {
            color: var(--primary);
            display: block;
            margin-bottom: 2px;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            background-color: var(--surface);
            color: var(--primary-dark);
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-right: 4px;
            margin-bottom: 6px;
        }

        .engineering-box {
            background: var(--surface);
            border: 2px solid var(--primary-light);
            padding: 14px;
            border-radius: 8px;
            margin-top: 16px;
        }

        .engineering-box h4 {
            margin: 0 0 8px 0;
            color: var(--primary-dark);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .engineering-box p {
            margin: 0 0 6px 0;
            font-size: 0.8rem;
            color: var(--text-main);
            line-height: 1.5;
        }

        .value-display {
            font-size: 0.8rem;
            padding: 6px 10px;
            background: var(--surface);
            border-radius: 6px;
            margin: 3px 0;
            font-family: 'Courier New', monospace;
            color: var(--primary-dark);
        }

        .forces-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--surface);
        }

        .force-item {
            padding: 8px;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .force-item:last-child {
            border-bottom: none;
        }

        .force-item button {
            width: auto;
            padding: 3px 6px;
            font-size: 0.7rem;
            margin: 0;
            background-color: var(--error);
        }

        .force-item button:hover {
            background-color: #dc2626;
        }

        .equilibrium-status {
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            font-size: 0.8rem;
            margin-top: 8px;
        }

        .equilibrium-status.balanced {
            background-color: rgba(16, 185, 129, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .equilibrium-status.unbalanced {
            background-color: rgba(239, 68, 68, 0.2);
            color: var(--error);
            border: 1px solid var(--error);
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <header style="position: relative;">
            <div style="position: absolute; top: 0; right: 0; display: flex; gap: 8px;">
                <select id="langSelect" style="width: auto; padding: 6px; font-size: 0.8rem;">
                    <option value="en">ðŸ‡ºðŸ‡¸ EN</option>
                    <option value="pl">ðŸ‡µðŸ‡± PL</option>
                    <option value="fr">ðŸ‡«ðŸ‡· FR</option>
                    <option value="es">ðŸ‡ªðŸ‡¸ ES</option>
                    <option value="pt">ðŸ‡µðŸ‡¹ PT</option>
                    <option value="de">ðŸ‡©ðŸ‡ª DE</option>
                    <option value="uk">ðŸ‡ºðŸ‡¦ UK</option>
                    <option value="be">ðŸ‡§ðŸ‡¾ BE</option>
                </select>
                <button id="themeToggle"
                    style="width: auto; margin:0; padding: 6px 10px; background: var(--card-bg); color: var(--text-main); border: 1px solid var(--border);">
                    <i data-lucide="moon" size="16"></i>
                </button>
            </div>
            <h1><i data-lucide="scale"
                    style="width: 32px; height: 32px; vertical-align: middle; margin-right: 8px;"></i> <span
                    data-i18n="title">2D Forces & Equilibrium Analyzer</span></h1>
            <p class="subtitle" data-i18n="subtitle">Visualize force systems, compute resultants, moments, and verify
                static equilibrium</p>
        </header>

        <div class="grid">
            <!-- Control Panel -->
            <div class="card">
                <div class="card-header"><i data-lucide="list-plus" style="margin-right: 8px;"></i> <span
                        data-i18n="addForcesCard">Add Forces</span></div>

                <div class="form-group">
                    <label>Magnitude (N): <span id="valMag">100</span></label>
                    <input type="number" id="inputMag" value="100" min="1" max="500" step="10">
                </div>

                <div class="form-group">
                    <label>Angle (Â°): <span id="valAngle">0</span></label>
                    <input type="number" id="inputAngle" value="0" min="0" max="360" step="5">
                </div>

                <div class="form-group">
                    <label>Point X (m): <span id="valX">0</span></label>
                    <input type="number" id="inputX" value="0" min="-10" max="10" step="0.5">
                </div>

                <div class="form-group">
                    <label>Point Y (m): <span id="valY">0</span></label>
                    <input type="number" id="inputY" value="0" min="-10" max="10" step="0.5">
                </div>

                <button id="btnAddForce" data-i18n="btnAdd">Add Force (Click Canvas)</button>
                <button id="btnClear" style="background-color: var(--warning);" data-i18n="btnClear">Clear All</button>

                <div class="badge">Forces</div>
                <div class="badge">Equilibrium</div>
                <div class="badge">Moments</div>

                <!-- Forces List -->
                <div style="margin-top: 16px;">
                    <h3 style="font-size: 0.9rem; margin: 0 0 8px 0; color: var(--primary-dark);"
                        data-i18n="activeForces">Active Forces</h3>
                    <div id="forcesList" class="forces-list"></div>
                </div>

                <!-- Equilibrium Status -->
                <div id="equilibriumStatus" class="equilibrium-status hidden">
                    âœ“ System in Equilibrium
                </div>

                <!-- Virtual Work Controls -->
                <div class="card-header"
                    style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 20px;"><i
                        data-lucide="zap" style="margin-right: 8px;"></i> <span data-i18n="virtWorkTitle">Virtual Work
                        (Masters)</span></div>
                <div class="form-group">
                    <label><span data-i18n="virtDisp">Virtual Displacement (Î´r)</span>: <span
                            id="valVirtDir">0Â°</span></label>
                    <input type="range" id="sliderVirtDir" min="0" max="360" value="0">
                </div>
                <div class="form-group">
                    <button id="btnToggleWork" style="background-color: var(--text-light);" data-i18n="btnVirt">Enable
                        Virtual Work Viz</button>
                    <div id="virtualWorkRes" class="value-display hidden">Î´W = 0.00 J</div>
                </div>

                <!-- Engineering Context -->
                <div style="margin-top: 16px;">
                    <h3 style="font-size: 0.9rem; margin: 0 0 8px 0; color: var(--primary-dark);"
                        data-i18n="appContext">Application</h3>
                    <select id="context"
                        style="width: 100%; padding: 6px 8px; font-size: 0.8rem; border: 1px solid var(--border); border-radius: 6px; background-color: var(--input-bg); color: var(--text-main);">
                        <option value="truss">Truss Joint Analysis</option>
                        <option value="beam">Beam Support Reactions</option>
                        <option value="pulley">Pulley System</option>
                        <option value="landing">Landing Gear Impact</option>
                    </select>
                </div>
            </div>

            <!-- Visualization & Analysis -->
            <div>
                <!-- Canvas -->
                <div class="card">
                    <div class="card-header"><i data-lucide="activity" style="margin-right: 8px;"></i> <span
                            data-i18n="forceDiag">Force Diagram
                            (Free-Body Diagram)</span></div>
                    <div class="canvas-container">
                        <canvas id="forceCanvas"></canvas>
                    </div>
                </div>

                <!-- Math Traceability (New) -->
                <div class="card">
                    <div class="card-header"><i data-lucide="calculator" style="margin-right: 8px;"></i> <span
                            data-i18n="calcDetails">Calculation
                            Details</span></div>
                    <div id="mathTrace" class="formula"
                        style="font-size: 0.9rem; line-height: 1.6; background: var(--surface); color: var(--text-main); overflow-x:auto;">
                        <!-- Content populated by JS -->
                    </div>
                </div>

                <!-- Resultant & Analysis -->
                <div class="card">
                    <div class="card-header"><i data-lucide="calculator" style="margin-right: 8px;"></i> <span
                            data-i18n="forceAnalysis">Force Analysis</span>
                    </div>

                    <div class="info-section">
                        <h3 data-i18n="resForce">Resultant Force</h3>
                        <div class="results-grid">
                            <div class="result-item">
                                <strong>Fx (N)</strong>
                                <span id="resFx">0.00</span>
                            </div>
                            <div class="result-item">
                                <strong>Fy (N)</strong>
                                <span id="resFy">0.00</span>
                            </div>
                            <div class="result-item">
                                <strong data-i18n="resMag">Magnitude</strong>
                                <span id="resMag">0.00 N</span>
                            </div>
                            <div class="result-item">
                                <strong data-i18n="resDir">Direction</strong>
                                <span id="resDir">0.00Â°</span>
                            </div>
                        </div>
                    </div>

                    <div class="info-section">
                        <h3 data-i18n="resMoment">Moment Analysis (about origin)</h3>
                        <div class="results-grid">
                            <div class="result-item">
                                <strong data-i18n="totalMoment">Total Moment (NÂ·m)</strong>
                                <span id="resMoment">0.00</span>
                            </div>
                            <div class="result-item">
                                <strong data-i18n="equilCheck">Equilibrium Check</strong>
                                <span id="equilCheck">Î£F â‰  0, Î£M â‰  0</span>
                            </div>
                        </div>
                    </div>

                    <div class="info-section">
                        <h3 data-i18n="equilCond">Equilibrium Conditions</h3>
                        <p><strong>Î£Fx = 0:</strong> <span id="checkFx">âœ— Not balanced</span></p>
                        <p><strong>Î£Fy = 0:</strong> <span id="checkFy">âœ— Not balanced</span></p>
                        <p><strong>Î£M = 0:</strong> <span id="checkMoment">âœ— Not balanced</span></p>
                    </div>
                </div>

                <!-- Free-Body Diagram Explanation -->
                <div class="card">
                    <div class="card-header"><i data-lucide="help-circle" style="margin-right: 8px;"></i> <span
                            data-i18n="howTo">How to Use</span>
                    </div>
                    <div class="info-section">
                        <h3 data-i18n="steps">Steps</h3>
                        <div data-i18n="stepsList"
                            style="font-size: 0.8rem; color: var(--text-light); line-height: 1.5;">
                            1. Enter force magnitude & angle.<br>2. Enter application point.<br>3. Click Add
                            Force.<br>4. Repeat for multiple forces.<br>5. Check Equilibrium.
                        </div>
                    </div>

                    <div class="info-section">
                        <h3 data-i18n="equilReq">Equilibrium Requirements</h3>
                        <div data-i18n="equilReqText"
                            style="font-size: 0.8rem; color: var(--text-light); line-height: 1.5;">
                            For static equilibrium: Î£Fx = 0, Î£Fy = 0, Î£M = 0. All three conditions must be satisfied.
                        </div>
                    </div>
                </div>

                <!-- Engineering Applications -->
                <div class="card">
                    <div class="card-header"><i data-lucide="book-open" style="margin-right: 8px;"></i> <span
                            data-i18n="realWorld">Real-World
                            Applications</span></div>
                    <div id="engineeringApp" class="engineering-box"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                title: "2D Forces & Equilibrium Analyzer",
                subtitle: "Visualize force systems, compute resultants, moments, and verify static equilibrium.",
                addForcesCard: "Add Forces",
                magLabel: "Magnitude (N)",
                angleLabel: "Angle (Â°)",
                ptX: "Point X (m)", ptY: "Point Y (m)",
                btnAdd: "Add Force (Click Canvas)", btnClear: "Clear All",
                activeForces: "Active Forces",
                virtWorkTitle: "Virtual Work (Masters)",
                virtDisp: "Virtual Displacement (Î´r)",
                btnVirt: "Enable Virtual Work Viz", btnVirtOff: "Disable Virtual Work",
                appContext: "Application",
                forceDiag: "Force Diagram (Free-Body Diagram)",
                calcDetails: "Calculation Details",
                forceAnalysis: "Force Analysis",
                resForce: "Resultant Force",
                resMoment: "Moment Analysis (about origin)",
                totalMoment: "Total Moment",
                equilCheck: "Equilibrium Check",
                equilCond: "Equilibrium Conditions",
                howTo: "How to Use",
                steps: "Steps",
                stepsList: "1. Enter force magnitude & angle.<br>2. Enter application point.<br>3. Click Add Force.<br>4. Repeat for multiple forces.<br>5. Check Equilibrium.",
                equilReq: "Equilibrium Requirements",
                equilReqText: "For static equilibrium: Î£Fx = 0, Î£Fy = 0, Î£M = 0. All three conditions must be satisfied.",
                realWorld: "Real-World Applications",
                noForces: "No forces added. Click canvas to set position, then 'Add Force'.",
                balanced: "âœ“ Balanced", unbalanced: "âœ— Not balanced",
                sysEquil: "âœ“ System in Equilibrium", sysNotEquil: "âœ— System Not in Equilibrium",
                resMag: "Magnitude", resDir: "Direction", remove: "Remove"
            },
            pl: {
                title: "Analizator SiÅ‚ i RÃ³wnowagi 2D",
                subtitle: "Wizualizacja ukÅ‚adÃ³w siÅ‚, obliczanie wypadkowych, momentÃ³w i weryfikacja rÃ³wnowagi statycznej.",
                addForcesCard: "Dodaj SiÅ‚y",
                magLabel: "WartoÅ›Ä‡ (N)",
                angleLabel: "KÄ…t (Â°)",
                ptX: "Punkt X (m)", ptY: "Punkt Y (m)",
                btnAdd: "Dodaj SiÅ‚Ä™ (Kliknij)", btnClear: "WyczyÅ›Ä‡",
                activeForces: "Aktywne SiÅ‚y",
                virtWorkTitle: "Praca Wirtualna (Magister)",
                virtDisp: "PrzesuniÄ™cie Wirtualne (Î´r)",
                btnVirt: "WÅ‚Ä…cz WizualizacjÄ™ Pracy", btnVirtOff: "WyÅ‚Ä…cz WizualizacjÄ™",
                appContext: "Zastosowanie",
                forceDiag: "Diagram SiÅ‚ (FBD)",
                calcDetails: "SzczegÃ³Å‚y ObliczeÅ„",
                forceAnalysis: "Analiza SiÅ‚",
                resForce: "SiÅ‚a Wypadkowa",
                resMoment: "Analiza Momentu (wzgl. 0,0)",
                totalMoment: "Moment CaÅ‚kowity",
                equilCheck: "Sprawdzenie RÃ³wnowagi",
                equilCond: "Warunki RÃ³wnowagi",
                howTo: "Instrukcja",
                steps: "Kroki",
                stepsList: "1. Wpisz wartoÅ›Ä‡ i kÄ…t siÅ‚y.<br>2. Wpisz punkt przyÅ‚oÅ¼enia.<br>3. Dodaj siÅ‚Ä™.<br>4. PowtÃ³rz dla innych.<br>5. SprawdÅº rÃ³wnowagÄ™.",
                equilReq: "Wymogi RÃ³wnowagi",
                equilReqText: "Dla rÃ³wnowagi statycznej: Î£Fx = 0, Î£Fy = 0, Î£M = 0.",
                realWorld: "Zastosowania w InÅ¼ynierii",
                noForces: "Brak siÅ‚. Kliknij na pÅ‚Ã³tnie i dodaj siÅ‚Ä™.",
                balanced: "âœ“ ZrÃ³wnowaÅ¼one", unbalanced: "âœ— NiezrÃ³wnowaÅ¼one",
                sysEquil: "âœ“ UkÅ‚ad w RÃ³wnowadze", sysNotEquil: "âœ— Brak RÃ³wnowagi",
                resMag: "WartoÅ›Ä‡", resDir: "Kierunek", remove: "UsuÅ„"
            },
            fr: { title: "Analyse des Forces 2D", subtitle: "Ã‰quilibre statique.", addForcesCard: "Ajouter Forces", magLabel: "Magnitude (N)", angleLabel: "Angle (Â°)", btnAdd: "Ajouter Force", btnClear: "Effacer", activeForces: "Forces Actives", forceDiag: "Diagramme des Forces", forceAnalysis: "Analyse", resForce: "RÃ©sultante", resMoment: "Moment", equilCond: "Conditions", balanced: "âœ“ Ã‰quilibrÃ©", unbalanced: "âœ— Non Ã‰quilibrÃ©", sysEquil: "âœ“ Ã‰quilibrÃ©", sysNotEquil: "âœ— Non Ã‰quilibrÃ©", stepsList: "Ajouter des forces et vÃ©rifier l'Ã©quilibre." },
            es: { title: "AnÃ¡lisis de Fuerzas 2D", subtitle: "Equilibrio estÃ¡tico.", addForcesCard: "AÃ±adir Fuerzas", magLabel: "Magnitud (N)", angleLabel: "Ãngulo (Â°)", btnAdd: "AÃ±adir Fuerza", btnClear: "Borrar", activeForces: "Fuerzas Activas", forceDiag: "Diagrama de Fuerzas", forceAnalysis: "AnÃ¡lisis", resForce: "Resultante", resMoment: "Momento", equilCond: "Condiciones", balanced: "âœ“ Equilibrado", unbalanced: "âœ— No Equilibrado", sysEquil: "âœ“ Equilibrado", sysNotEquil: "âœ— No Equilibrado", stepsList: "AÃ±adir fuerzas y verificar equilibrio." },
            pt: { title: "AnÃ¡lise de ForÃ§as 2D", subtitle: "EquilÃ­brio estÃ¡tico.", addForcesCard: "Adicionar ForÃ§as", magLabel: "Magnitude (N)", angleLabel: "Ã‚ngulo (Â°)", btnAdd: "Adicionar ForÃ§a", btnClear: "Limpar", activeForces: "ForÃ§as Ativas", forceDiag: "Diagrama de ForÃ§as", forceAnalysis: "AnÃ¡lise", resForce: "Resultante", resMoment: "Momento", equilCond: "CondiÃ§Ãµes", balanced: "âœ“ Equilibrado", unbalanced: "âœ— NÃ£o Equilibrado", sysEquil: "âœ“ Equilibrado", sysNotEquil: "âœ— NÃ£o Equilibrado", stepsList: "Adicionar forÃ§as e verificar equilibrio." },
            de: { title: "Kraftanalyse 2D", subtitle: "Statisches Gleichgewicht.", addForcesCard: "KrÃ¤fte hinzufÃ¼gen", magLabel: "Betrag (N)", angleLabel: "Winkel (Â°)", btnAdd: "Kraft hinzufÃ¼gen", btnClear: "LÃ¶schen", activeForces: "Aktive KrÃ¤fte", forceDiag: "KrÃ¤ftediagramm", forceAnalysis: "Analyse", resForce: "Resultierende", resMoment: "Moment", equilCond: "Bedingungen", balanced: "âœ“ Gleichgewicht", unbalanced: "âœ— Ungleichgewicht", sysEquil: "âœ“ Im Gleichgewicht", sysNotEquil: "âœ— Nicht im Gleichgewicht", stepsList: "KrÃ¤fte hinzufÃ¼gen und Gleichgewicht prÃ¼fen." },
            uk: { title: "ÐÐ½Ð°Ð»Ñ–Ð· Ð¡Ð¸Ð» 2D", subtitle: "Ð¡Ñ‚Ð°Ñ‚Ð¸Ñ‡Ð½Ð° Ñ€Ñ–Ð²Ð½Ð¾Ð²Ð°Ð³Ð°.", addForcesCard: "Ð”Ð¾Ð´Ð°Ñ‚Ð¸ Ð¡Ð¸Ð»Ð¸", magLabel: "Ð’ÐµÐ»Ð¸Ñ‡Ð¸Ð½Ð° (N)", angleLabel: "ÐšÑƒÑ‚ (Â°)", btnAdd: "Ð”Ð¾Ð´Ð°Ñ‚Ð¸ Ð¡Ð¸Ð»Ñƒ", btnClear: "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚Ð¸", activeForces: "ÐÐºÑ‚Ð¸Ð²Ð½Ñ– Ð¡Ð¸Ð»Ð¸", forceDiag: "Ð”Ñ–Ð°Ð³Ñ€Ð°Ð¼Ð° Ð¡Ð¸Ð»", forceAnalysis: "ÐÐ½Ð°Ð»Ñ–Ð·", resForce: "Ð Ñ–Ð²Ð½Ð¾Ð´Ñ–Ð¹Ð½Ð°", resMoment: "ÐœÐ¾Ð¼ÐµÐ½Ñ‚", equilCond: "Ð£Ð¼Ð¾Ð²Ð¸", balanced: "âœ“ Ð—Ð±Ð°Ð»Ð°Ð½ÑÐ¾Ð²Ð°Ð½Ð¾", unbalanced: "âœ— ÐÐµ Ð·Ð±Ð°Ð»Ð°Ð½ÑÐ¾Ð²Ð°Ð½Ð¾", sysEquil: "âœ“ Ð Ñ–Ð²Ð½Ð¾Ð²Ð°Ð³Ð°", sysNotEquil: "âœ— ÐÐµÐ¼Ð°Ñ” Ñ€Ñ–Ð²Ð½Ð¾Ð²Ð°Ð³Ð¸", stepsList: "Ð”Ð¾Ð´Ð°Ð¹Ñ‚Ðµ ÑÐ¸Ð»Ð¸ Ñ‚Ð° Ð¿ÐµÑ€ÐµÐ²Ñ–Ñ€Ñ‚Ðµ Ñ€Ñ–Ð²Ð½Ð¾Ð²Ð°Ð³Ñƒ." },
            be: { title: "ÐÐ½Ð°Ð»Ñ–Ð· Ð¡Ñ–Ð» 2D", subtitle: "Ð¡Ñ‚Ð°Ñ‚Ñ‹Ñ‡Ð½Ð°Ñ Ñ€Ð°ÑžÐ½Ð°Ð²Ð°Ð³Ð°.", addForcesCard: "Ð”Ð°Ð´Ð°Ñ†ÑŒ Ð¡Ñ–Ð»Ñ‹", magLabel: "Ð’ÐµÐ»Ñ–Ñ‡Ñ‹Ð½Ñ (N)", angleLabel: "ÐšÑƒÑ‚ (Â°)", btnAdd: "Ð”Ð°Ð´Ð°Ñ†ÑŒ Ð¡Ñ–Ð»Ñƒ", btnClear: "ÐÑ‡Ñ‹ÑÑ†Ñ–Ñ†ÑŒ", activeForces: "ÐÐºÑ‚Ñ‹ÑžÐ½Ñ‹Ñ Ð¡Ñ–Ð»Ñ‹", forceDiag: "Ð”Ñ‹ÑÐ³Ñ€Ð°Ð¼Ð° Ð¡Ñ–Ð»", forceAnalysis: "ÐÐ½Ð°Ð»Ñ–Ð·", resForce: "Ð’Ñ‹Ð½Ñ–ÐºÐ¾Ð²Ð°Ñ", resMoment: "ÐœÐ¾Ð¼Ð°Ð½Ñ‚", equilCond: "Ð£Ð¼Ð¾Ð²Ñ‹", balanced: "âœ“ Ð—Ð±Ð°Ð»Ð°Ð½ÑÐ°Ð²Ð°Ð½Ð°", unbalanced: "âœ— ÐÐµ Ð·Ð±Ð°Ð»Ð°Ð½ÑÐ°Ð²Ð°Ð½Ð°", sysEquil: "âœ“ Ð Ð°ÑžÐ½Ð°Ð²Ð°Ð³Ð°", sysNotEquil: "âœ— ÐÑÐ¼Ð° Ñ€Ð°ÑžÐ½Ð°Ð²Ð°Ð³Ñ–", stepsList: "Ð”Ð°Ð´Ð°Ð¹Ñ†Ðµ ÑÑ–Ð»Ñ‹ Ñ– Ð¿Ñ€Ð°Ð²ÐµÑ€Ñ†Ðµ Ñ€Ð°ÑžÐ½Ð°Ð²Ð°Ð³Ñƒ." }
        };

        const app = {
            lang: 'en', // Default
            theme: 'light',

            setTheme: (t) => {
                app.theme = t;
                document.documentElement.setAttribute('data-theme', t);
                localStorage.setItem('theme', t);
                const icon = t === 'dark' ? 'sun' : 'moon';
                // Note: Header icons in P4 are Lucide icons, but Toggle button icon needs update
                document.getElementById('themeToggle').innerHTML = `<i data-lucide="${icon}" size="16"></i>`;
                lucide.createIcons();
                app.draw(); // Redraw canvas
            },

            setLang: (l) => {
                app.lang = l;
                localStorage.setItem('lang', l);
                document.getElementById('langSelect').value = l;
                app.updateTranslations();
                app.update(); // Trigger re-render of dynamic strings
            },

            updateTranslations: () => {
                const t = translations[app.lang];
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) {
                        if (key === 'stepsList' || key === 'equilReqText') el.innerHTML = t[key];
                        else el.textContent = t[key];
                    }
                });

                // Manual updates
                document.getElementById('inputMag').previousElementSibling.firstChild.textContent = t.magLabel + ': ';
                document.getElementById('inputAngle').previousElementSibling.firstChild.textContent = t.angleLabel + ': ';
            },

            canvas: null,
            ctx: null,
            forces: [],
            state: {
                magnitude: 100,
                angle: 0,
                x: 0,
                y: 0,
                context: 'truss',
                virtualWork: false,
                virtAngle: 0,
                dragging: -1 // Index of force being dragged, -1 if none
            },

            init: () => {
                // Init Theme/Lang
                const savedTheme = localStorage.getItem('theme') || 'light';
                app.setTheme(savedTheme);
                const savedLang = localStorage.getItem('lang') || 'en';
                app.setLang(savedLang);

                document.getElementById('themeToggle').addEventListener('click', () => {
                    app.setTheme(app.theme === 'dark' ? 'light' : 'dark');
                });
                document.getElementById('langSelect').addEventListener('change', (e) => {
                    app.setLang(e.target.value);
                });

                app.canvas = document.getElementById('forceCanvas');
                app.ctx = app.canvas.getContext('2d');

                // Set canvas size
                const container = app.canvas.parentElement;
                app.canvas.width = container.clientWidth;
                app.canvas.height = container.clientHeight;

                // Event listeners for inputs
                document.getElementById('inputMag').addEventListener('input', (e) => {
                    app.state.magnitude = parseFloat(e.target.value);
                    document.getElementById('valMag').textContent = app.state.magnitude.toFixed(0);
                });

                document.getElementById('inputAngle').addEventListener('input', (e) => {
                    app.state.angle = parseFloat(e.target.value);
                    document.getElementById('valAngle').textContent = app.state.angle.toFixed(0);
                });

                document.getElementById('inputX').addEventListener('input', (e) => {
                    app.state.x = parseFloat(e.target.value);
                    document.getElementById('valX').textContent = app.state.x.toFixed(1);
                });

                document.getElementById('inputY').addEventListener('input', (e) => {
                    app.state.y = parseFloat(e.target.value);
                    document.getElementById('valY').textContent = app.state.y.toFixed(1);
                });

                document.getElementById('btnAddForce').addEventListener('click', app.addForce);
                document.getElementById('btnClear').addEventListener('click', app.clearAll);
                document.getElementById('context').addEventListener('change', (e) => {
                    app.state.context = e.target.value;
                    app.displayEngineering();
                });

                document.getElementById('sliderVirtDir').addEventListener('input', (e) => {
                    app.state.virtAngle = parseFloat(e.target.value) * Math.PI / 180;
                    document.getElementById('valVirtDir').textContent = e.target.value + 'Â°';
                    app.update();
                });

                document.getElementById('btnToggleWork').addEventListener('click', () => {
                    app.state.virtualWork = !app.state.virtualWork;
                    const btn = document.getElementById('btnToggleWork');
                    const res = document.getElementById('virtualWorkRes');

                    if (app.state.virtualWork) {
                        btn.style.backgroundColor = 'var(--primary)';
                        btn.textContent = 'Disable Virtual Work';
                        res.classList.remove('hidden');
                    } else {
                        btn.style.backgroundColor = 'var(--text-light)';
                        btn.textContent = 'Enable Virtual Work Viz';
                        res.classList.add('hidden');
                    }
                    app.update();
                });

                app.canvas.addEventListener('mousedown', app.handleMouseDown);
                app.canvas.addEventListener('mousemove', app.handleMouseMove);
                app.canvas.addEventListener('mouseup', app.handleMouseUp);

                // Keep click for adding new forces if not dragging
                // app.canvas.addEventListener('click', ...); // Replaced by mousedown/up logic


                app.displayEngineering();
                app.draw();
                lucide.createIcons();
                app.updateTranslations(); // Initial translation apply
            },

            scale: 30,
            offsetX: 0,
            offsetY: 0,

            addForce: () => {
                const force = {
                    magnitude: app.state.magnitude,
                    angle: app.state.angle * Math.PI / 180,
                    x: app.state.x,
                    y: app.state.y,
                    fx: app.state.magnitude * Math.cos(app.state.angle * Math.PI / 180),
                    fy: app.state.magnitude * Math.sin(app.state.angle * Math.PI / 180)
                };
                app.forces.push(force);
                app.update();
            },

            clearAll: () => {
                app.forces = [];
                app.update();
            },

            removeForce: (index) => {
                app.forces.splice(index, 1);
                app.update();
            },

            update: () => {
                app.updateForcesList();
                app.calculateResultant();
                app.calculateMoments();
                app.draw();
            },

            getMousePos: (e) => {
                const rect = app.canvas.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left) / app.scale - app.offsetX,
                    y: -(e.clientY - rect.top) / app.scale + app.offsetY
                };
            },

            handleMouseDown: (e) => {
                const m = app.getMousePos(e);
                const w = app.canvas.width;
                const h = app.canvas.height;
                const centerX = w / 2;
                const centerY = h / 2;

                // Check collisions with existing forces (heads) to change magnitude/angle
                // Or check collision with origin points to move force
                // For simplified UX: Dragging the HEAD changes Mag/Angle. Dragging the TAIL changes X/Y.

                // 1. Check Heads
                let hit = -1;
                app.forces.forEach((f, i) => {
                    const fx = centerX + f.x * app.scale;
                    const fy = centerY - f.y * app.scale;
                    const headX = fx + f.fx / f.magnitude * Math.min(100, f.magnitude * 0.5); // approximate visual head
                    // Actually let's use the explicit math from draw()
                    const arrowLen = Math.min(100, f.magnitude * 0.5);
                    const hx = fx + Math.cos(f.angle) * arrowLen;
                    const hy = fy - Math.sin(f.angle) * arrowLen;

                    // Hit test in PIXELS
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    // This is tricky because getMousePos returns physics coords.
                    // Let's stick to physics coords distance ~ 0.5m radius?
                    // Or just screen distance.
                });
                // Let's implement simpler: Click = Place "Ghost" cursor.
                // Dragging = If we click NEAR a force head, we drag the head.

                const pos = app.getMousePos(e);

                // Find nearest force head
                let minDist = 1.0; // 1 meter interaction radius
                let dragIdx = -1;

                app.forces.forEach((f, i) => {
                    // Head pos in physics units
                    const arrowLen = Math.min(100, f.magnitude * 0.5) / app.scale;
                    const headX = f.x + Math.cos(f.angle) * arrowLen;
                    const headY = f.y + Math.sin(f.angle) * arrowLen;

                    const d = Math.sqrt(Math.pow(pos.x - headX, 2) + Math.pow(pos.y - headY, 2));
                    if (d < minDist) {
                        minDist = d;
                        dragIdx = i;
                    }
                });

                if (dragIdx !== -1) {
                    app.state.dragging = dragIdx;
                } else {
                    // If we didn't hit a force, move the placement cursor
                    app.state.x = pos.x;
                    app.state.y = pos.y;
                    document.getElementById('inputX').value = pos.x.toFixed(1);
                    document.getElementById('inputY').value = pos.y.toFixed(1);
                    document.getElementById('valX').textContent = pos.x.toFixed(1);
                    document.getElementById('valY').textContent = pos.y.toFixed(1);
                }
            },

            handleMouseMove: (e) => {
                if (app.state.dragging !== -1) {
                    const pos = app.getMousePos(e);
                    const f = app.forces[app.state.dragging];

                    // Calculate new angle/mag based on drag
                    // Vector from Tail to Mouse
                    const dx = pos.x - f.x;
                    const dy = pos.y - f.y;

                    f.angle = Math.atan2(dy, dx);
                    if (f.angle < 0) f.angle += 2 * Math.PI;

                    // Mag is distance, scaled back from visual limit?
                    // Visual length was min(100, mag*0.5).
                    // This is hard to reverse. 
                    // Let's just say Mag = Distance * 10? Simple mapping.
                    // Or keep Mag independent? Users usually want to drag to point.
                    // Let's make force vector simply follow mouse, so Mag ~ length.
                    f.magnitude = Math.sqrt(dx * dx + dy * dy) * 20;
                    if (f.magnitude > 500) f.magnitude = 500;

                    f.fx = f.magnitude * Math.cos(f.angle);
                    f.fy = f.magnitude * Math.sin(f.angle);

                    app.update();
                }

                // Hover cursor
                const canvas = app.canvas;
                // canvas.style.cursor = hit ? 'move' : 'crosshair'; 
            },

            handleMouseUp: (e) => {
                app.state.dragging = -1;
            },

            updateForcesList: () => {
                const list = document.getElementById('forcesList');
                const t = translations[app.lang];
                list.innerHTML = '';
                if (app.forces.length === 0) {
                    list.innerHTML = `<div style="padding: 8px; text-align: center; color: var(--text-light); font-size: 0.75rem;">${t.noForces}</div>`;
                    return;
                }

                app.forces.forEach((f, i) => {
                    const item = document.createElement('div');
                    item.className = 'force-item';
                    item.innerHTML = `
                        <span><strong>F${i + 1}:</strong> ${f.magnitude.toFixed(0)}N @ ${(f.angle * 180 / Math.PI).toFixed(0)}Â° at (${f.x}, ${f.y})</span>
                        <button onclick="app.removeForce(${i})">${t.remove}</button>
                    `;
                    list.appendChild(item);
                });
            },


            calculateResultant: () => {
                let sumFx = 0, sumFy = 0;
                app.forces.forEach(f => {
                    sumFx += f.fx;
                    sumFy += f.fy;
                });

                const magnitude = Math.sqrt(sumFx * sumFx + sumFy * sumFy);
                const direction = Math.atan2(sumFy, sumFx) * 180 / Math.PI;

                document.getElementById('resFx').textContent = sumFx.toFixed(2);
                document.getElementById('resFy').textContent = sumFy.toFixed(2);
                document.getElementById('resMag').textContent = magnitude.toFixed(2) + ' N';
                document.getElementById('resDir').textContent = direction.toFixed(2) + 'Â°';

                const fxBalanced = Math.abs(sumFx) < 0.1;
                const fyBalanced = Math.abs(sumFy) < 0.1;

                document.getElementById('checkFx').innerHTML = fxBalanced ? 'âœ“ Balanced' : 'âœ— Not balanced';
                document.getElementById('checkFx').style.color = fxBalanced ? 'var(--success)' : 'var(--error)';

                document.getElementById('checkFy').innerHTML = fyBalanced ? 'âœ“ Balanced' : 'âœ— Not balanced';
                document.getElementById('checkFy').style.color = fyBalanced ? 'var(--success)' : 'var(--error)';

                return { sumFx, sumFy, fxBalanced, fyBalanced };
            },

            calculateMoments: () => {
                let sumM = 0;
                app.forces.forEach(f => {
                    const moment = f.x * f.fy - f.y * f.fx;
                    sumM += moment;
                });

                document.getElementById('resMoment').textContent = sumM.toFixed(2);

                const mBalanced = Math.abs(sumM) < 0.1;
                const t = translations[app.lang];
                document.getElementById('checkMoment').innerHTML = mBalanced ? t.balanced : t.unbalanced;
                document.getElementById('checkMoment').style.color = mBalanced ? 'var(--success)' : 'var(--error)';

                const result = app.calculateResultant();
                const allBalanced = result.fxBalanced && result.fyBalanced && mBalanced;

                const status = document.getElementById('equilibriumStatus');
                if (allBalanced && app.forces.length > 0) {
                    status.textContent = t.sysEquil;
                    status.classList.remove('unbalanced');
                    status.classList.add('balanced');
                    status.classList.remove('hidden');
                } else if (app.forces.length > 0) {
                    status.textContent = t.sysNotEquil;
                    status.classList.remove('balanced');
                    status.classList.add('unbalanced');
                    status.classList.remove('hidden');
                } else {
                    status.classList.add('hidden');
                }

                // Traceability Display
                let html = `<strong>Sum of Forces (X):</strong> $\\sum F_x = 0$<br>`;
                html += `$$ `;
                if (app.forces.length === 0) html += `0 = 0`;
                else {
                    const terms = app.forces.map(f => f.fx.toFixed(1)).join(' + ');
                    html += `${terms} = ${sumFx.toFixed(2)}`;
                }
                html += ` $$ <br>`;

                html += `<strong>Sum of Forces (Y):</strong> $\\sum F_y = 0$<br>`;
                html += `$$ `;
                if (app.forces.length === 0) html += `0 = 0`;
                else {
                    const terms = app.forces.map(f => f.fy.toFixed(1)).join(' + ');
                    html += `${terms} = ${sumFy.toFixed(2)}`;
                }
                html += ` $$`;

                document.getElementById('mathTrace').innerHTML = html;
                if (window.MathJax) MathJax.typesetPromise();

                return sumM;
            },

            draw: () => {
                const w = app.canvas.width;
                const h = app.canvas.height;
                const ctx = app.ctx;

                // Define centerX/centerY as they are used in the rest of the function
                const centerX = w / 2;
                const centerY = h / 2;

                // Clear
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--grid-bg');
                ctx.fillRect(0, 0, w, h);

                // Grid
                const gridColor = getComputedStyle(document.body).getPropertyValue('--grid-line');
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;

                // Draw grid lines
                for (let i = -10; i <= 10; i++) {
                    // Vertical
                    ctx.beginPath();
                    ctx.moveTo(centerX + i * app.scale, 0);
                    ctx.lineTo(centerX + i * app.scale, h);
                    ctx.stroke();

                    // Horizontal
                    ctx.beginPath();
                    ctx.moveTo(0, centerY + i * app.scale);
                    ctx.lineTo(w, centerY + i * app.scale);
                    ctx.stroke();
                }

                // Draw axes
                app.ctx.strokeStyle = '#64748b';
                app.ctx.lineWidth = 2;
                app.ctx.beginPath();
                app.ctx.moveTo(0, centerY);
                app.ctx.lineTo(w, centerY);
                app.ctx.stroke();
                app.ctx.beginPath();
                app.ctx.moveTo(centerX, 0);
                app.ctx.lineTo(centerX, h);
                app.ctx.stroke();

                // Labels
                app.ctx.fillStyle = '#64748b';
                app.ctx.font = '12px Inter';
                app.ctx.fillText('X (m)', w - 30, centerY - 10);
                app.ctx.fillText('Y (m)', centerX + 10, 20);

                // Draw origin point
                app.ctx.fillStyle = '#0f766e';
                app.ctx.beginPath();
                app.ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
                app.ctx.fill();

                // Draw forces
                app.forces.forEach((f, idx) => {
                    const fx = centerX + f.x * app.scale;
                    const fy = centerY - f.y * app.scale;

                    // Force application point
                    app.ctx.fillStyle = 'rgba(15, 118, 110, 0.3)';
                    app.ctx.beginPath();
                    app.ctx.arc(fx, fy, 5, 0, 2 * Math.PI);
                    app.ctx.fill();

                    // Force vector
                    const arrowLen = Math.min(100, app.state.magnitude * 0.5);
                    const fx_scaled = Math.cos(f.angle) * arrowLen;
                    const fy_scaled = -Math.sin(f.angle) * arrowLen;

                    const colors = ['#0f766e', '#14b8a6', '#10b981', '#f59e0b'];
                    app.ctx.strokeStyle = colors[idx % colors.length];
                    app.ctx.lineWidth = 2.5;
                    app.ctx.beginPath();
                    app.ctx.moveTo(fx, fy);
                    app.ctx.lineTo(fx + fx_scaled, fy + fy_scaled);
                    app.ctx.stroke();

                    // Arrowhead
                    const headlen = 10;
                    const angle = Math.atan2(fy_scaled, fx_scaled);
                    app.ctx.beginPath();
                    app.ctx.moveTo(fx + fx_scaled, fy + fy_scaled);
                    app.ctx.lineTo(fx + fx_scaled - headlen * Math.cos(angle - Math.PI / 6), fy + fy_scaled - headlen * Math.sin(angle - Math.PI / 6));
                    app.ctx.moveTo(fx + fx_scaled, fy + fy_scaled);
                    app.ctx.lineTo(fx + fx_scaled - headlen * Math.cos(angle + Math.PI / 6), fy + fy_scaled - headlen * Math.sin(angle + Math.PI / 6));
                    app.ctx.stroke();

                    // Label
                    app.ctx.fillStyle = colors[idx % colors.length];
                    app.ctx.font = 'bold 11px Inter';
                    app.ctx.fillText(`F${idx + 1}: ${f.magnitude.toFixed(0)}N`, fx + 15, fy - 10);
                });

                // Draw resultant
                if (app.forces.length > 0) {
                    let sumFx = 0, sumFy = 0;
                    app.forces.forEach(f => {
                        sumFx += f.fx;
                        sumFy += f.fy;
                    });

                    const resMag = Math.sqrt(sumFx * sumFx + sumFy * sumFy);
                    if (resMag > 0.1) {
                        const arrowLen = Math.min(120, resMag * 0.5);
                        const rx = (sumFx / resMag) * arrowLen;
                        const ry = -(sumFy / resMag) * arrowLen;

                        app.ctx.strokeStyle = '#ef4444';
                        app.ctx.lineWidth = 3;
                        app.ctx.setLineDash([5, 5]);
                        app.ctx.beginPath();
                        app.ctx.moveTo(centerX, centerY);
                        app.ctx.lineTo(centerX + rx, centerY + ry);
                        app.ctx.stroke();
                        app.ctx.setLineDash([]);

                        // Arrowhead
                        const angle = Math.atan2(ry, rx);
                        const headlen = 10;
                        app.ctx.beginPath();
                        app.ctx.moveTo(centerX + rx, centerY + ry);
                        app.ctx.lineTo(centerX + rx - headlen * Math.cos(angle - Math.PI / 6), centerY + ry - headlen * Math.sin(angle - Math.PI / 6));
                        app.ctx.moveTo(centerX + rx, centerY + ry);
                        app.ctx.lineTo(centerX + rx - headlen * Math.cos(angle + Math.PI / 6), centerY + ry - headlen * Math.sin(angle + Math.PI / 6));
                        app.ctx.stroke();

                        app.ctx.fillStyle = '#ef4444';
                        app.ctx.font = 'bold 12px Inter';
                        app.ctx.fillText(`Î£F=${resMag.toFixed(1)}N`, centerX + rx + 15, centerY + ry);
                    }
                }

                // Draw Virtual Work
                if (app.state.virtualWork) {
                    const dr = 40; // visual length of virtual displacement
                    const dx = Math.cos(app.state.virtAngle) * dr;
                    const dy = -Math.sin(app.state.virtAngle) * dr; // canvas Y inverted

                    // Draw Phantom Center
                    app.ctx.globalAlpha = 0.5;
                    app.ctx.fillStyle = '#f59e0b';
                    app.ctx.beginPath(); app.ctx.arc(centerX + dx, centerY + dy, 4, 0, 2 * Math.PI); app.ctx.fill();

                    // Draw Displacement Vector at Origin
                    app.ctx.strokeStyle = '#f59e0b';
                    app.ctx.setLineDash([2, 2]);
                    app.ctx.lineWidth = 2;
                    app.ctx.beginPath();
                    app.ctx.moveTo(centerX, centerY);
                    app.ctx.lineTo(centerX + dx, centerY + dy);
                    app.ctx.stroke();

                    // Calculate Total Virtual Work
                    let totalWork = 0;

                    // Draw Ghost Forces at new position
                    app.forces.forEach(f => {
                        const ghostX = centerX + f.x * app.scale + dx;
                        const ghostY = centerY - f.y * app.scale + dy;

                        // Ghost point
                        app.ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
                        app.ctx.beginPath(); app.ctx.arc(ghostX, ghostY, 3, 0, 2 * Math.PI); app.ctx.fill();

                        // Calc Work: F dot dr
                        // dr vector in physics coords is (cos(a), sin(a))
                        // F vector is (fx, fy)
                        const physDx = Math.cos(app.state.virtAngle);
                        const physDy = Math.sin(app.state.virtAngle);
                        const work = f.fx * physDx + f.fy * physDy;
                        totalWork += work;
                    });

                    app.ctx.setLineDash([]);
                    app.ctx.globalAlpha = 1.0;

                    const res = document.getElementById('virtualWorkRes');
                    res.innerHTML = `Î´W = Î£ FÂ·Î´r = <strong>${totalWork.toFixed(1)}</strong> (J)`;
                    if (Math.abs(totalWork) < 1.0) {
                        res.style.color = 'var(--success)';
                        res.innerHTML += ' âœ“ Equilibrium';
                    } else {
                        res.style.color = 'var(--error)';
                        res.innerHTML += ' âœ— Non-zero Work';
                    }
                }
            },

            displayEngineering: () => {
                const ctx = app.state.context;
                let html = '';

                const contexts = {
                    truss: {
                        title: '<i data-lucide="triangle" style="width:16px; height:16px; margin-right:4px; vertical-align:text-bottom;"></i> Truss Joint Analysis',
                        desc: 'Forces at pin joints must be in equilibrium. Find member forces (tension/compression) by solving Î£Fx=0, Î£Fy=0. Method of joints uses force equilibrium at each node.',
                        example: 'At a truss joint, all forces must sum to zero for static equilibrium.'
                    },
                    beam: {
                        title: '<i data-lucide="columns" style="width:16px; height:16px; margin-right:4px; vertical-align:text-bottom;"></i> Beam Support Reactions',
                        desc: 'Distributed loads and concentrated forces on beams create reactions at supports. Sum forces vertically/horizontally and sum moments about support points to find reaction forces and moments.',
                        example: 'Sum moments about one support to find the other reaction, then use Î£Fy=0.'
                    },
                    pulley: {
                        title: '<i data-lucide="anchor" style="width:16px; height:16px; margin-right:4px; vertical-align:text-bottom;"></i> Pulley & Cable Systems',
                        desc: 'Ideal (frictionless) pulleys change force direction. Tensions in cables connected through pulleys are equal if massless. Equilibrium of the load applies: sum of cable tensions = load weight.',
                        example: 'For a single movable pulley: 2T = Weight (force is halved, distance doubled).'
                    },
                    landing: {
                        title: '<i data-lucide="plane-landing" style="width:16px; height:16px; margin-right:4px; vertical-align:text-bottom;"></i> Landing Gear Impact Forces',
                        desc: 'During landing, the fuselage weight transfers through the landing gear (shock struts, oleos) to the ground. Forces at contact must equilibrate weight + inertial forces. Critical for structural design.',
                        example: 'Multi-point landing gear distributes vertical load; side forces arise from crosswind and braking.'
                    }
                };

                const info = contexts[ctx];
                html += `<h4>${info.title}</h4>`;
                html += `<p>${info.desc}</p>`;
                html += `<p><strong>Key Principle:</strong> ${info.example}</p>`;

                const result = app.calculateResultant();
                const sumM = app.calculateMoments();

                html += `<div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(20, 184, 166, 0.3);">`;
                html += `<strong>Current System State:</strong><br/>`;
                html += `<span class="value-display">Resultant: ${Math.sqrt(result.sumFx * result.sumFx + result.sumFy * result.sumFy).toFixed(2)} N</span>`;
                html += `<span class="value-display">Moment: ${sumM.toFixed(2)} NÂ·m</span>`;
                if (result.fxBalanced && result.fyBalanced && Math.abs(sumM) < 0.1) {
                    html += `<p style="color: var(--success); margin-top: 8px; font-weight: 600;">âœ“ Equilibrium achieved!</p>`;
                } else {
                    html += `<p style="color: var(--warning); margin-top: 8px; font-weight: 600;">âš ï¸ Add more forces to achieve equilibrium</p>`;
                }
                html += `</div>`;

                document.getElementById('engineeringApp').innerHTML = html;
                lucide.createIcons();
            }
        };

        window.onload = app.init;
    </script>
</body>

</html>