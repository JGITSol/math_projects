<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signals & Fourier Playground | Applied Mathematics</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
</head>

<body class="project-page">
    <div class="container">
        <header>
            <div class="header-content">
                <a href="../index.html" class="back-link">
                    <i data-lucide="arrow-left"></i> Back to Hub
                </a>
                <h1 data-i18n="title">üåä Signals & Fourier Playground</h1>
                <p class="subtitle" data-i18n="subtitle">Explore time-domain signals, frequency-domain transforms, and signal filtering in real-world applications</p>
            </div>
        </header>

        <div class="grid">
            <!-- Control Panel -->
            <div class="card">
                <div class="card-header">‚öôÔ∏è Configuration</div>

                <!-- Signal Type -->
                <div class="form-group">
                    <label for="signalType">Signal Type</label>
                    <select id="signalType">
                        <option value="sine">Pure Sine Wave</option>
                        <option value="composite">Composite (Multi-Freq)</option>
                        <option value="square">Square Wave</option>
                        <option value="sawtooth">Sawtooth Wave</option>
                        <option value="noise">White Noise</option>
                    </select>
                </div>

                <!-- Frequency 1 -->
                <div class="form-group">
                    <label>Primary Freq (Hz): <span id="valFreq1">10</span></label>
                    <input type="range" id="sliderFreq1" min="1" max="50" step="1" value="10">
                </div>

                <!-- Frequency 2 (for composite) -->
                <div class="form-group" id="groupFreq2">
                    <label>Secondary Freq (Hz): <span id="valFreq2">20</span></label>
                    <input type="range" id="sliderFreq2" min="1" max="50" step="1" value="20">
                </div>

                <!-- Amplitude -->
                <div class="form-group">
                    <label>Amplitude: <span id="valAmplitude">1.0</span></label>
                    <input type="range" id="sliderAmplitude" min="0.1" max="2" step="0.1" value="1">
                </div>

                <!-- Filter Type -->
                <div class="form-group">
                    <label for="filterType">Filter Type</label>
                    <select id="filterType">
                        <option value="none">No Filter</option>
                        <option value="lowpass">Low-Pass (Cut High)</option>
                        <option value="highpass">High-Pass (Cut Low)</option>
                        <option value="bandpass">Band-Pass (Isolate Mid)</option>
                    </select>
                </div>

                <!-- Filter Cutoff -->
                <div class="form-group" id="groupCutoff">
                    <label>Cutoff Freq (Hz): <span id="valCutoff">15</span></label>
                    <input type="range" id="sliderCutoff" min="1" max="40" step="1" value="15">
                </div>

                <button id="btnUpdate" data-i18n="updateBtn">Update Visualization</button>

                <div class="badge" data-i18n="badgeSignal">Signal</div>
                <div class="badge" data-i18n="badgeFourier">Fourier</div>
                <div class="badge" data-i18n="badgeFilter">Filter</div>
            </div>

            <!-- Visualization & Analysis -->
            <div>
                <!-- Time & Frequency Domain Plots -->
                <div class="card">
                    <div class="card-header">üìä Time Domain & Frequency Spectrum</div>

                    <div class="dual-chart">
                        <div>
                            <div class="chart-label">Time Domain (Raw Signal)</div>
                            <div class="chart-container">
                                <canvas id="timeChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <div class="chart-label">Frequency Domain (Spectrum)</div>
                            <div class="chart-container">
                                <canvas id="freqChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Filtered Signal -->
                <div class="card">
                    <div class="card-header">üîß Filtered Signal (Time Domain)</div>
                    <div class="chart-container">
                        <canvas id="filteredChart"></canvas>
                    </div>
                </div>

                <!-- Mathematical Concepts -->
                <div class="card">
                    <div class="card-header">üìê Signal Processing Concepts</div>
                    <div id="formulaDisplay"></div>
                    <div class="info-section">
                        <h3>Fourier Transform Explained</h3>
                        <p id="conceptExplanation"></p>
                    </div>
                    <div id="filterInfo" class="info-section">
                        <h3>Filter Response</h3>
                        <p id="filterDescription"></p>
                    </div>
                </div>

                <!-- Engineering Application -->
                <div class="card">
                    <div class="card-header">‚ö° Real-World Applications</div>
                    <div class="tab-header">
                        <button class="tab-btn active" data-tab="audio">Audio</button>
                        <button class="tab-btn" data-tab="motor">Motor</button>
                        <button class="tab-btn" data-tab="sensor">Sensor</button>
                        <button class="tab-btn" data-tab="communication">Comms</button>
                        <button class="tab-btn" data-tab="vibration">Vibration</button>
                    </div>
                    <div id="engineeringApp" class="engineering-box"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                title: "üåä Signals & Fourier Playground",
                subtitle: "Explore time-domain signals, frequency-domain transforms, and real-world applications",
                config: "‚öôÔ∏è Configuration",
                signalType: "Signal Type",
                freq1: "Primary Freq (Hz)",
                freq2: "Secondary Freq (Hz)",
                amplitude: "Amplitude",
                filterType: "Filter Type",
                cutoff: "Cutoff Freq (Hz)",
                appContext: "Application",
                updateBtn: "Update Visualization",
                badgeSignal: "Signal",
                badgeFourier: "Fourier",
                badgeFilter: "Filter",
                timeDomain: "Time Domain (Raw Signal)",
                freqDomain: "Frequency Domain (Spectrum)",
                filteredSignal: "Filtered Signal (Time Domain)",
                concepts: "üìê Signal Processing Concepts",
                applications: "‚ö° Real-World Applications",

                // Select options
                sine: "Pure Sine Wave",
                composite: "Composite (Multi-Freq)",
                square: "Square Wave",
                sawtooth: "Sawtooth Wave",
                noise: "White Noise",

                none: "No Filter",
                lowpass: "Low-Pass (Cut High)",
                highpass: "High-Pass (Cut Low)",
                bandpass: "Band-Pass (Isolate Mid)",

                audio: "Audio & Music",
                motor: "Motor Control (PWM)",
                sensor: "Sensor Filtering",
                communication: "Communication Signals",
                vibration: "Vibration Analysis"
            },
            pl: {
                title: "üåä Sygna≈Çy i Transformata Fouriera",
                subtitle: "Eksploruj sygna≈Çy w dziedzinie czasu, transformaty czƒôstotliwo≈õciowe i filtrowanie",
                config: "‚öôÔ∏è Konfiguracja",
                signalType: "Typ Sygna≈Çu",
                freq1: "Czƒôst. Podstawowa (Hz)",
                freq2: "Czƒôst. Wt√≥rna (Hz)",
                amplitude: "Amplituda",
                filterType: "Typ Filtra",
                cutoff: "Czƒôst. Odciƒôcia (Hz)",
                appContext: "Zastosowanie",
                updateBtn: "Aktualizuj Wizualizacjƒô",
                badgeSignal: "Sygna≈Ç",
                badgeFourier: "Fourier",
                badgeFilter: "Filtr",
                timeDomain: "Dziedzina Czasu (Sygna≈Ç Surowy)",
                freqDomain: "Dziedzina Czƒôstotliwo≈õci (Widmo)",
                filteredSignal: "Sygna≈Ç Przefiltrowany",
                concepts: "üìê Koncepcje Przetwarzania Sygna≈Ç√≥w",
                applications: "‚ö° Zastosowania Praktyczne",
                sine: "Czysta Sinusoida",
                composite: "Sygna≈Ç Z≈Ço≈ºony",
                square: "Fala ProstokƒÖtna",
                sawtooth: "Fala Pi≈Çokszta≈Çtna",
                noise: "Bia≈Çy Szum",
                none: "Brak Filtra",
                lowpass: "Dolnoprzepustowy",
                highpass: "G√≥rnoprzepustowy",
                bandpass: "Pasmowoprzepustowy",
                audio: "Audio i Muzyka",
                motor: "Sterowanie Silnikiem (PWM)",
                sensor: "Filtrowanie Czujnik√≥w",
                communication: "Sygna≈Çy Komunikacyjne",
                vibration: "Analiza Wibracji"
            },
            fr: {
                title: "üåä Signaux et Fourier",
                subtitle: "Explorez les signaux temporels, les transform√©es fr√©quentielles et le filtrage",
                config: "‚öôÔ∏è Configuration",
                signalType: "Type de Signal",
                freq1: "Fr√©q. Primaire (Hz)",
                freq2: "Fr√©q. Secondaire (Hz)",
                amplitude: "Amplitude",
                filterType: "Type de Filtre",
                cutoff: "Fr√©q. de Coupure (Hz)",
                appContext: "Application",
                updateBtn: "Mettre √† jour",
                badgeSignal: "Signal",
                badgeFourier: "Fourier",
                badgeFilter: "Filtre",
                timeDomain: "Domaine Temporel",
                freqDomain: "Domaine Fr√©quentiel",
                filteredSignal: "Signal Filtr√©",
                concepts: "üìê Concepts de Traitement du Signal",
                applications: "‚ö° Applications R√©elles",
                sine: "Onde Sinuso√Ødale",
                composite: "Signal Composite",
                square: "Onde Carr√©e",
                sawtooth: "Onde en Dents de Scie",
                noise: "Bruit Blanc",
                none: "Aucun Filtre",
                lowpass: "Passe-Bas",
                highpass: "Passe-Haut",
                bandpass: "Passe-Bande",
                audio: "Audio & Musique",
                motor: "Contr√¥le Moteur (PWM)",
                sensor: "Filtrage de Capteurs",
                communication: "Signaux de Communication",
                vibration: "Analyse Vibratoire"
            },
            es: {
                title: "üåä Se√±ales y Fourier",
                subtitle: "Explora se√±ales en el dominio del tiempo, transformadas de frecuencia y filtrado",
                config: "‚öôÔ∏è Configuraci√≥n",
                signalType: "Tipo de Se√±al",
                freq1: "Frec. Primaria (Hz)",
                freq2: "Frec. Secundaria (Hz)",
                amplitude: "Amplitud",
                filterType: "Tipo de Filtro",
                cutoff: "Frec. de Corte (Hz)",
                appContext: "Aplicaci√≥n",
                updateBtn: "Actualizar",
                badgeSignal: "Se√±al",
                badgeFourier: "Fourier",
                badgeFilter: "Filtro",
                timeDomain: "Dominio del Tiempo",
                freqDomain: "Dominio de Frecuencia",
                filteredSignal: "Se√±al Filtrada",
                concepts: "üìê Conceptos de Procesamiento de Se√±ales",
                applications: "‚ö° Aplicaciones Reales",
                sine: "Onda Senoidal",
                composite: "Se√±al Compuesta",
                square: "Onda Cuadrada",
                sawtooth: "Onda Dientes de Sierra",
                noise: "Ruido Blanco",
                none: "Sin Filtro",
                lowpass: "Paso Bajo",
                highpass: "Paso Alto",
                bandpass: "Paso Banda",
                audio: "Audio y M√∫sica",
                motor: "Control de Motor (PWM)",
                sensor: "Filtrado de Sensores",
                communication: "Se√±ales de Comunicaci√≥n",
                vibration: "An√°lisis de Vibraciones"
            },
            pt: {
                title: "üåä Sinais e Fourier",
                subtitle: "Explore sinais no dom√≠nio do tempo, transformadas de frequ√™ncia e filtragem",
                config: "‚öôÔ∏è Configura√ß√£o",
                signalType: "Tipo de Sinal",
                freq1: "Freq. Prim√°ria (Hz)",
                freq2: "Freq. Secund√°ria (Hz)",
                amplitude: "Amplitude",
                filterType: "Tipo de Filtro",
                cutoff: "Freq. de Corte (Hz)",
                appContext: "Aplica√ß√£o",
                updateBtn: "Atualizar Visualiza√ß√£o",
                badgeSignal: "Sinal",
                badgeFourier: "Fourier",
                badgeFilter: "Filtro",
                timeDomain: "Dom√≠nio do Tempo",
                freqDomain: "Dom√≠nio da Frequ√™ncia",
                filteredSignal: "Sinal Filtrado",
                concepts: "üìê Conceitos de Processamento de Sinais",
                applications: "‚ö° Aplica√ß√µes Reais",
                sine: "Onda Senoidal Pura",
                composite: "Sinal Composto",
                square: "Onda Quadrada",
                sawtooth: "Onda Dente de Serra",
                noise: "Ru√≠do Branco",
                none: "Sem Filtro",
                lowpass: "Passa-Baixa",
                highpass: "Passa-Alta",
                bandpass: "Passa-Banda",
                audio: "√Åudio e M√∫sica",
                motor: "Controle de Motor (PWM)",
                sensor: "Filtragem de Sensores",
                communication: "Sinais de Comunica√ß√£o",
                vibration: "An√°lise de Vibra√ß√£o"
            },
            de: {
                title: "üåä Signale & Fourier",
                subtitle: "Erkunden Sie Zeitsignale, Frequenztransformationen und Filtertechnik",
                config: "‚öôÔ∏è Konfiguration",
                signalType: "Signaltyp",
                freq1: "Prim√§rfrequenz (Hz)",
                freq2: "Sekund√§rfrequenz (Hz)",
                amplitude: "Amplitude",
                filterType: "Filtertyp",
                cutoff: "Grenzfrequenz (Hz)",
                appContext: "Anwendung",
                updateBtn: "Visualisierung Aktualisieren",
                badgeSignal: "Signal",
                badgeFourier: "Fourier",
                badgeFilter: "Filter",
                timeDomain: "Zeitbereich (Rohsignal)",
                freqDomain: "Frequenzbereich (Spektrum)",
                filteredSignal: "Gefiltertes Signal",
                concepts: "üìê Signalverarbeitungskonzepte",
                applications: "‚ö° Reale Anwendungen",
                sine: "Reine Sinuswelle",
                composite: "Zusammengesetztes Signal",
                square: "Rechteckwelle",
                sawtooth: "S√§gezahnwelle",
                noise: "Wei√ües Rauschen",
                none: "Kein Filter",
                lowpass: "Tiefpass",
                highpass: "Hochpass",
                bandpass: "Bandpass",
                audio: "Audio & Musik",
                motor: "Motorsteuerung (PWM)",
                sensor: "Sensorfilterung",
                communication: "Kommunikationssignale",
                vibration: "Vibrationsanalyse"
            },
            ua: {
                title: "üåä –°–∏–≥–Ω–∞–ª–∏ —Ç–∞ –§—É—Ä'—î",
                subtitle: "–î–æ—Å–ª—ñ–¥–∂—É–π—Ç–µ —Å–∏–≥–Ω–∞–ª–∏ —É —á–∞—Å–æ–≤—ñ–π –æ–±–ª–∞—Å—Ç—ñ, —á–∞—Å—Ç–æ—Ç–Ω—ñ –ø–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∞ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—é",
                config: "‚öôÔ∏è –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è",
                signalType: "–¢–∏–ø –°–∏–≥–Ω–∞–ª—É",
                freq1: "–û—Å–Ω–æ–≤–Ω–∞ –ß–∞—Å—Ç–æ—Ç–∞ (–ì—Ü)",
                freq2: "–í—Ç–æ—Ä–∏–Ω–Ω–∞ –ß–∞—Å—Ç–æ—Ç–∞ (–ì—Ü)",
                amplitude: "–ê–º–ø–ª—ñ—Ç—É–¥–∞",
                filterType: "–¢–∏–ø –§—ñ–ª—å—Ç—Ä—É",
                cutoff: "–ß–∞—Å—Ç–æ—Ç–∞ –ó—Ä—ñ–∑—É (–ì—Ü)",
                appContext: "–ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è",
                updateBtn: "–û–Ω–æ–≤–∏—Ç–∏ –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é",
                badgeSignal: "–°–∏–≥–Ω–∞–ª",
                badgeFourier: "–§—É—Ä'—î",
                badgeFilter: "–§—ñ–ª—å—Ç—Ä",
                timeDomain: "–ß–∞—Å–æ–≤–∞ –û–±–ª–∞—Å—Ç—å",
                freqDomain: "–ß–∞—Å—Ç–æ—Ç–Ω–∞ –û–±–ª–∞—Å—Ç—å",
                filteredSignal: "–í—ñ–¥—Ñ—ñ–ª—å—Ç—Ä–æ–≤–∞–Ω–∏–π –°–∏–≥–Ω–∞–ª",
                concepts: "üìê –ö–æ–Ω—Ü–µ–ø—Ü—ñ—ó –û–±—Ä–æ–±–∫–∏ –°–∏–≥–Ω–∞–ª—ñ–≤",
                applications: "‚ö° –ü—Ä–∞–∫—Ç–∏—á–Ω—ñ –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è",
                sine: "–ß–∏—Å—Ç–∞ –°–∏–Ω—É—Å–æ—ó–¥–∞",
                composite: "–°–∫–ª–∞–¥–Ω–∏–π –°–∏–≥–Ω–∞–ª",
                square: "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∞ –•–≤–∏–ª—è",
                sawtooth: "–ü–∏–ª–∫–æ–ø–æ–¥—ñ–±–Ω–∞ –•–≤–∏–ª—è",
                noise: "–ë—ñ–ª–∏–π –®—É–º",
                none: "–ë–µ–∑ –§—ñ–ª—å—Ç—Ä—É",
                lowpass: "–ù–∏–∑—å–∫—ñ –ß–∞—Å—Ç–æ—Ç–∏",
                highpass: "–í–∏—Å–æ–∫—ñ –ß–∞—Å—Ç–æ—Ç–∏",
                bandpass: "–°–º—É–≥–æ–≤–∏–π –§—ñ–ª—å—Ç—Ä",
                audio: "–ê—É–¥—ñ–æ —Ç–∞ –ú—É–∑–∏–∫–∞",
                motor: "–ö–µ—Ä—É–≤–∞–Ω–Ω—è –î–≤–∏–≥—É–Ω–æ–º (PWM)",
                sensor: "–§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è –î–∞—Ç—á–∏–∫—ñ–≤",
                communication: "–°–∏–≥–Ω–∞–ª–∏ –ó–≤'—è–∑–∫—É",
                vibration: "–ê–Ω–∞–ª—ñ–∑ –í—ñ–±—Ä–∞—Ü—ñ–π"
            },
            be: {
                title: "üåä –°—ñ–≥–Ω–∞–ª—ã —ñ –§—É—Ä'–µ",
                subtitle: "–î–∞—Å–ª–µ–¥—É–π—Ü–µ —Å—ñ–≥–Ω–∞–ª—ã —û —á–∞—Å–∞–≤–æ–π –≤–æ–±–ª–∞—Å—Ü—ñ, —á–∞—Å—Ç–æ—Ç–Ω—ã—è –ø–µ—Ä–∞—û—Ç–≤–∞—Ä—ç–Ω–Ω—ñ —ñ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ã—é",
                config: "‚öôÔ∏è –ö–∞–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ã—è",
                signalType: "–¢—ã–ø –°—ñ–≥–Ω–∞–ª—É",
                freq1: "–ê—Å–Ω–æ—û–Ω–∞—è –ß–∞—Å—Ç–∞—Ç–∞ (–ì—Ü)",
                freq2: "–î—Ä—É–≥–∞—Å–Ω–∞—è –ß–∞—Å—Ç–∞—Ç–∞ (–ì—Ü)",
                amplitude: "–ê–º–ø–ª—ñ—Ç—É–¥–∞",
                filterType: "–¢—ã–ø –§—ñ–ª—å—Ç—Ä–∞",
                cutoff: "–ß–∞—Å—Ç–∞—Ç–∞ –ó—Ä—ç–∑—É (–ì—Ü)",
                appContext: "–£–∂—ã–≤–∞–Ω–Ω–µ",
                updateBtn: "–ê–±–Ω–∞–≤—ñ—Ü—å –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ã—é",
                badgeSignal: "–°—ñ–≥–Ω–∞–ª",
                badgeFourier: "–§—É—Ä'–µ",
                badgeFilter: "–§—ñ–ª—å—Ç—Ä",
                timeDomain: "–ß–∞—Å–∞–≤–∞—è –í–æ–±–ª–∞—Å—Ü—å",
                freqDomain: "–ß–∞—Å—Ç–æ—Ç–Ω–∞—è –í–æ–±–ª–∞—Å—Ü—å",
                filteredSignal: "–ê—Ç—Ñ—ñ–ª—å—Ç—Ä–∞–≤–∞–Ω—ã –°—ñ–≥–Ω–∞–ª",
                concepts: "üìê –ö–∞–Ω—Ü—ç–ø—Ü—ã—ñ –ê–ø—Ä–∞—Ü–æ—û–∫—ñ –°—ñ–≥–Ω–∞–ª–∞—û",
                applications: "‚ö° –ü—Ä–∞–∫—Ç—ã—á–Ω–∞–µ –£–∂—ã–≤–∞–Ω–Ω–µ",
                sine: "–ß—ã—Å—Ç–∞—è –°—ñ–Ω—É—Å–æ—ñ–¥–∞",
                composite: "–°–∫–ª–∞–¥–∞–Ω—ã –°—ñ–≥–Ω–∞–ª",
                square: "–ü—Ä–∞—Å—Ç–∞–∫—É—Ç–Ω–∞—è –•–≤–∞–ª—è",
                sawtooth: "–ü—ñ–ª–∞–ø–∞–¥–æ–±–Ω–∞—è –•–≤–∞–ª—è",
                noise: "–ë–µ–ª—ã –®—É–º",
                none: "–ë–µ–∑ –§—ñ–ª—å—Ç—Ä–∞",
                lowpass: "–ù—ñ–∑–∫—ñ—è –ß–∞—Å—Ç–æ—Ç—ã",
                highpass: "–í—ã—Å–æ–∫—ñ—è –ß–∞—Å—Ç–æ—Ç—ã",
                bandpass: "–ü–∞–ª–∞—Å–∞–≤—ã –§—ñ–ª—å—Ç—Ä",
                audio: "–ê—û–¥—ã—ë —ñ –ú—É–∑—ã–∫–∞",
                motor: "–ö—ñ—Ä–∞–≤–∞–Ω–Ω–µ –†—É—Ö–∞–≤—ñ–∫–æ–º (PWM)",
                sensor: "–§—ñ–ª—å—Ç—Ä–∞—Ü—ã—è –î–∞—Ç—á—ã–∫–∞—û",
                communication: "–°—ñ–≥–Ω–∞–ª—ã –°—É–≤—è–∑—ñ",
                vibration: "–ê–Ω–∞–ª—ñ–∑ –í—ñ–±—Ä–∞—Ü—ã–π"
            }
        };

        const app = {
            timeChart: null,
            freqChart: null,
            filteredChart: null,
            state: {
                signalType: 'sine',
                freq1: 10,
                freq2: 20,
                amplitude: 1,
                filterType: 'none',
                cutoff: 15,
                context: 'audio'
            },
            lang: 'en',
            theme: 'light',

            // setTheme and setLang removed - handled by site.js

            // Generate time-domain signal
            generateSignal: (t) => {
                const f1 = app.state.freq1;
                const f2 = app.state.freq2;
                const A = app.state.amplitude;
                const type = app.state.signalType;

                let signal = 0;
                if (type === 'sine') {
                    signal = A * Math.sin(2 * Math.PI * f1 * t);
                } else if (type === 'composite') {
                    signal = A * (0.6 * Math.sin(2 * Math.PI * f1 * t) + 0.4 * Math.sin(2 * Math.PI * f2 * t));
                } else if (type === 'square') {
                    const period = 1 / f1;
                    const tMod = t % period;
                    signal = A * (tMod < period / 2 ? 1 : -1);
                } else if (type === 'sawtooth') {
                    const period = 1 / f1;
                    signal = A * 2 * (t / period - Math.floor(t / period + 0.5));
                } else if (type === 'noise') {
                    signal = A * (Math.random() - 0.5) * 2;
                }
                return signal;
            },

            // Simple FFT approximation (frequency bin analysis)
            computeSpectrum: (timeData, fs = 100) => {
                const spectrum = [];
                const maxFreq = fs / 2;
                const freqBins = 50;

                for (let k = 0; k < freqBins; k++) {
                    const freq = (k / freqBins) * maxFreq;
                    let realPart = 0, imagPart = 0;

                    for (let n = 0; n < timeData.length; n++) {
                        const angle = -2 * Math.PI * freq * n / fs;
                        realPart += timeData[n] * Math.cos(angle);
                        imagPart += timeData[n] * Math.sin(angle);
                    }

                    const magnitude = Math.sqrt(realPart * realPart + imagPart * imagPart) / timeData.length;
                    spectrum.push({ freq, magnitude });
                }
                return spectrum;
            },

            // Simple filter (frequency cutoff)
            applyFilter: (spectrum) => {
                const filtered = spectrum.map(bin => {
                    const f = bin.freq;
                    const fc = app.state.cutoff;
                    const type = app.state.filterType;

                    let response = 1;
                    if (type === 'lowpass') {
                        response = f < fc ? 1 : Math.max(0, 1 - (f - fc) / 20);
                    } else if (type === 'highpass') {
                        response = f > fc ? 1 : Math.max(0, (f) / fc);
                    } else if (type === 'bandpass') {
                        const bw = 10;
                        response = Math.abs(f - fc) < bw ? 1 : Math.max(0, 1 - Math.abs(f - fc) / 20);
                    }

                    return {
                        freq: bin.freq,
                        magnitude: bin.magnitude * response,
                        response: response
                    };
                });
                return filtered;
            },

            // Inverse approximate (recreate filtered signal)
            inverseSpectrum: (filteredSpectrum, duration = 1, fs = 100) => {
                const timePoints = Math.round(duration * fs);
                const signal = [];

                for (let n = 0; n < timePoints; n++) {
                    const t = n / fs;
                    let value = 0;

                    for (const bin of filteredSpectrum) {
                        value += bin.magnitude * Math.cos(2 * Math.PI * bin.freq * t);
                    }

                    signal.push(value);
                }
                return signal;
            },

            init: () => {
                document.getElementById('signalType').addEventListener('change', (e) => {
                    app.state.signalType = e.target.value;
                    app.updateFormDisplay();
                    app.update();
                });

                document.getElementById('sliderFreq1').addEventListener('input', (e) => {
                    app.state.freq1 = parseInt(e.target.value);
                    document.getElementById('valFreq1').textContent = app.state.freq1;
                    app.update();
                });

                document.getElementById('sliderFreq2').addEventListener('input', (e) => {
                    app.state.freq2 = parseInt(e.target.value);
                    document.getElementById('valFreq2').textContent = app.state.freq2;
                    app.update();
                });

                document.getElementById('sliderAmplitude').addEventListener('input', (e) => {
                    app.state.amplitude = parseFloat(e.target.value);
                    document.getElementById('valAmplitude').textContent = app.state.amplitude.toFixed(1);
                    app.update();
                });

                document.getElementById('filterType').addEventListener('change', (e) => {
                    app.state.filterType = e.target.value;
                    app.updateFormDisplay();
                    app.update();
                });

                document.getElementById('sliderCutoff').addEventListener('input', (e) => {
                    app.state.cutoff = parseInt(e.target.value);
                    document.getElementById('valCutoff').textContent = app.state.cutoff;
                    app.update();
                });

                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        app.state.context = e.target.getAttribute('data-tab');
                        app.update();
                    });
                });

                // Listen for site.js events
                window.addEventListener('themechange', (e) => {
                    app.theme = e.detail.theme;
                    app.updateChartTheme();
                    app.update(); // Re-render charts
                });
                
                window.addEventListener('langchange', (e) => {
                    app.lang = e.detail.lang;
                    app.updateTranslations();
                    app.update();
                });

                // Initial sync
                app.theme = document.documentElement.getAttribute('data-theme') || 'light';
                app.lang = document.documentElement.getAttribute('lang') || 'en';
                app.updateTranslations();

                app.updateFormDisplay();
                app.initCharts();
                app.update();
                lucide.createIcons();
            },

            updateTranslations: () => {
                const t = translations[app.lang];
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) el.innerHTML = t[key];
                });
                // Manual updates for selects if needed, or rely on updateFormDisplay
            },

            updateFormDisplay: () => {
                const show = app.state.signalType === 'composite';
                document.getElementById('groupFreq2').classList.toggle('hidden', !show);
                document.getElementById('groupCutoff').classList.toggle('hidden', app.state.filterType === 'none');
            },

            hexToRgba: (hex, alpha) => {
                let r = 0, g = 0, b = 0;
                // Handle rgb/rgba strings
                if (hex.startsWith('rgb')) return hex.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                
                if (hex.length === 4) {
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) {
                    r = parseInt(hex.slice(1, 3), 16);
                    g = parseInt(hex.slice(3, 5), 16);
                    b = parseInt(hex.slice(5, 7), 16);
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },

            getVar: (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim(),

            getChartColors: () => {
                const primary = app.getVar('--primary');
                const accent = app.getVar('--accent');
                const success = app.getVar('--success');
                
                return {
                    text: app.getVar('--text-light'),
                    grid: app.getVar('--border'),
                    primary: primary,
                    primaryBg: app.hexToRgba(primary, 0.1),
                    secondary: accent,
                    secondaryBg: app.hexToRgba(accent, 0.6),
                    success: success,
                    successBg: app.hexToRgba(success, 0.1)
                };
            },

            updateChartTheme: () => {
                const colors = app.getChartColors();
                
                const updateChart = (chart) => {
                    if (!chart) return;
                    
                    if (chart.options.scales.x) {
                        chart.options.scales.x.title.color = colors.text;
                        chart.options.scales.x.grid.color = colors.grid;
                        chart.options.scales.x.ticks.color = colors.text;
                    }
                    if (chart.options.scales.y) {
                        chart.options.scales.y.title.color = colors.text;
                        chart.options.scales.y.grid.color = colors.grid;
                        chart.options.scales.y.ticks.color = colors.text;
                    }
                    
                    if (chart.options.plugins.legend) {
                        chart.options.plugins.legend.labels.color = colors.text;
                    }
                };

                updateChart(app.timeChart);
                updateChart(app.freqChart);
                updateChart(app.filteredChart);

                if (app.timeChart) {
                    app.timeChart.data.datasets[0].borderColor = colors.primary;
                    app.timeChart.data.datasets[0].backgroundColor = colors.primaryBg;
                    app.timeChart.update();
                }
                if (app.freqChart) {
                    app.freqChart.data.datasets[0].borderColor = colors.secondary;
                    app.freqChart.data.datasets[0].backgroundColor = colors.secondaryBg;
                    app.freqChart.update();
                }
                if (app.filteredChart) {
                    app.filteredChart.data.datasets[0].borderColor = colors.success;
                    app.filteredChart.data.datasets[0].backgroundColor = colors.successBg;
                    app.filteredChart.update();
                }
            },

            initCharts: () => {
                const colors = app.getChartColors();
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: colors.text, font: { size: 11 } } }
                    },
                    scales: {
                        x: {
                            type: 'linear', min: 0, max: 1,
                            title: { display: true, text: translations[app.lang]?.timeDesc || 'Time (s)', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        },
                        y: {
                            title: { display: true, text: 'Amplitude', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        }
                    }
                };

                const timeCtx = document.getElementById('timeChart').getContext('2d');
                app.timeChart = new Chart(timeCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Signal', data: [], borderColor: colors.primary, backgroundColor: colors.primaryBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: commonOptions
                });

                const freqCtx = document.getElementById('freqChart').getContext('2d');
                app.freqChart = new Chart(freqCtx, {
                    type: 'bar',
                    data: { labels: [], datasets: [{ label: 'Magnitude', data: [], backgroundColor: colors.secondaryBg, borderColor: colors.secondary, borderWidth: 1 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: {
                                type: 'linear', min: 0, max: 50,
                                title: { display: true, text: 'Frequency (Hz)', color: colors.text },
                                grid: { color: colors.grid },
                                ticks: { color: colors.text }
                            },
                            y: {
                                title: { display: true, text: 'Magnitude', color: colors.text },
                                grid: { color: colors.grid },
                                ticks: { color: colors.text }
                            }
                        }
                    }
                });

                const filtCtx = document.getElementById('filteredChart').getContext('2d');
                app.filteredChart = new Chart(filtCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Filtered Signal', data: [], borderColor: colors.success, backgroundColor: colors.successBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: commonOptions
                });
            },

            update: () => {
                app.generatePlots();
                app.displayConcepts();
                app.displayEngineering();
            },

            generatePlots: () => {
                const fs = 100;
                const duration = 1;
                const timePoints = duration * fs;

                // Generate raw time-domain signal
                const timeData = [];
                const timeLabels = [];
                for (let i = 0; i < timePoints; i++) {
                    const t = i / fs;
                    timeData.push(app.generateSignal(t));
                    timeLabels.push(t.toFixed(2));
                }

                app.timeChart.data.labels = timeLabels;
                app.timeChart.data.datasets[0].data = timeData;
                app.timeChart.update();

                // Compute spectrum
                const spectrum = app.computeSpectrum(timeData, fs);
                const freqLabels = spectrum.map(b => b.freq.toFixed(1));
                const freqMagnitudes = spectrum.map(b => b.magnitude);

                app.freqChart.data.labels = freqLabels;
                app.freqChart.data.datasets[0].data = freqMagnitudes;
                app.freqChart.update();

                // Apply filter & inverse transform
                if (app.state.filterType === 'none') {
                    app.filteredChart.data.labels = timeLabels;
                    app.filteredChart.data.datasets[0].data = timeData;
                } else {
                    const filtered = app.applyFilter(spectrum);
                    const filteredSignal = app.inverseSpectrum(filtered, duration, fs);
                    app.filteredChart.data.labels = timeLabels;
                    app.filteredChart.data.datasets[0].data = filteredSignal;
                }
                app.filteredChart.update();
            },

            displayConcepts: () => {
                const st = app.state.signalType;
                const ft = app.state.filterType;

                let concept = '';
                if (st === 'sine') {
                    concept = `<strong>Pure Sine Wave:</strong> f(t) = A¬∑sin(2œÄft)<br/>Single frequency component. Fundamental to all signal processing.`;
                } else if (st === 'composite') {
                    concept = `<strong>Composite Signal:</strong> f(t) = 0.6¬∑sin(2œÄf‚ÇÅt) + 0.4¬∑sin(2œÄf‚ÇÇt)<br/>Multiple frequencies combined. Requires frequency analysis to separate.`;
                } else if (st === 'square') {
                    concept = `<strong>Square Wave:</strong> Discontinuous periodic signal.<br/>Fourier series: infinite sum of odd harmonics. Used in digital circuits.`;
                } else if (st === 'sawtooth') {
                    concept = `<strong>Sawtooth Wave:</strong> Linear ramp repeating.<br/>Contains all harmonics. Rich frequency spectrum.`;
                } else if (st === 'noise') {
                    concept = `<strong>White Noise:</strong> Random signal with uniform frequency distribution.<br/>Flat spectrum. Used in system identification and dithering.`;
                }

                document.getElementById('formulaDisplay').innerHTML = `<div class="formula">${concept}</div>`;

                let explainer = 'The Fourier Transform decomposes any signal into its frequency components. X(f) = ‚à´ x(t)e^(-j2œÄft) dt. This shows what frequencies are present and their amplitudes. Inverse transform reconstructs the time-domain signal from frequency data.';
                document.getElementById('conceptExplanation').textContent = explainer;

                if (ft !== 'none') {
                    let filterDesc = '';
                    if (ft === 'lowpass') {
                        filterDesc = `Low-Pass Filter: Attenuates high frequencies, passes low frequencies. Cutoff at ${app.state.cutoff} Hz. Used to smooth signals and remove noise.`;
                    } else if (ft === 'highpass') {
                        filterDesc = `High-Pass Filter: Attenuates low frequencies, passes high frequencies. Cutoff at ${app.state.cutoff} Hz. Used to remove DC offset and low-frequency drift.`;
                    } else if (ft === 'bandpass') {
                        filterDesc = `Band-Pass Filter: Isolates frequencies near ${app.state.cutoff} Hz with ~10 Hz bandwidth. Used in communication and audio equalization.`;
                    }
                    document.getElementById('filterDescription').textContent = filterDesc;
                    document.getElementById('filterInfo').classList.remove('hidden');
                } else {
                    document.getElementById('filterInfo').classList.add('hidden');
                }
            },

            displayEngineering: () => {
                const ctx = app.state.context;
                let html = '';

                const applications = {
                    audio: {
                        title: 'üéµ Audio & Music Production',
                        desc: 'Frequency analysis shows audio spectrum. Filters are used in equalizers to boost/cut bass, midrange, treble. Low-pass removes high-frequency noise. High-pass removes rumble and hum.',
                        example: 'Cutoff at ' + app.state.cutoff + ' Hz affects music character.'
                    },
                    motor: {
                        title: 'üîå Motor Control (PWM)',
                        desc: 'PWM signals contain fundamental and harmonics. Low-pass filter smooths PWM into analog equivalent. Reduces motor noise and electromagnetic interference (EMI).',
                        example: 'PWM frequency ~20 kHz; filter cutoff ~' + app.state.cutoff + ' Hz eliminates ripple.'
                    },
                    sensor: {
                        title: 'üìä Sensor Data Filtering',
                        desc: 'Real sensors produce noise across frequency spectrum. Band-pass isolates true signal. Low-pass removes high-frequency measurement noise from accelerometers, temperature sensors.',
                        example: 'Cutoff ' + app.state.cutoff + ' Hz: balance responsiveness vs noise rejection.'
                    },
                    communication: {
                        title: 'üì° Communication Signals',
                        desc: 'Modulated signals (AM/FM) occupy specific frequency bands. Filters separate channels. Bandwidth determines data rate. Frequency allocation prevents interference.',
                        example: 'Signal centered at ' + app.state.freq1 + ' Hz ¬± bandwidth.'
                    },
                    vibration: {
                        title: 'üìç Vibration Analysis',
                        desc: 'Machinery produces characteristic frequencies (bearing defects, imbalance, resonance). FFT reveals which frequencies have high amplitude. Indicates mechanical health and failure modes.',
                        example: 'Peaks in spectrum at ' + app.state.freq1 + ' Hz and harmonics signal defects.'
                    }
                };

                const app_info = applications[ctx];
                html += `<h4>${app_info.title}</h4>`;
                html += `<p>${app_info.desc}</p>`;
                html += `<p><strong>Current Setting:</strong> ${app_info.example}</p>`;

                const spectrum = app.computeSpectrum(
                    Array.from({ length: 100 }, (_, i) => app.generateSignal(i / 100)), 100
                );
                const peakFreq = spectrum.reduce((max, b) => b.magnitude > max.magnitude ? b : max).freq;

                html += `<div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">`;
                html += `<strong>Signal Analysis:</strong><br/>`;
                html += `<span class="value-display">Primary Frequency: ${peakFreq.toFixed(1)} Hz</span>`;
                html += `<span class="value-display">Filter Type: ${app.state.filterType === 'none' ? 'None (All Frequencies)' : app.state.filterType.toUpperCase()}</span>`;
                html += `<span class="value-display">Amplitude: ${app.state.amplitude.toFixed(1)}x</span>`;
                html += `</div>`;

                document.getElementById('engineeringApp').innerHTML = html;
            }
        };

        window.onload = app.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>