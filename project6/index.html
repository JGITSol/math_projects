<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Equations & Bode Plots | Applied Mathematics</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
</head>

<body class="project-page">
    <div class="container">
        <header>
            <div class="header-content">
                <a href="../index.html" class="back-link">
                    <i data-lucide="arrow-left"></i> Back to Hub
                </a>
                <h1 data-i18n="title">‚ö° Circuit Equations & Bode Plots</h1>
                <p class="subtitle" data-i18n="subtitle">RLC circuits, transfer functions, resonance, and frequency response analysis</p>
            </div>
        </header>

        <div class="grid">
            <!-- Control Panel -->
            <div class="card">
                <div class="card-header">‚öôÔ∏è Configuration</div>

                <!-- Circuit Topology -->
                <div class="form-group">
                    <label>Circuit Topology</label>
                    <div class="tab-container" id="topologyTabs">
                        <div class="tab-header">
                            <button class="tab-btn active" data-value="series">Series RLC</button>
                            <button class="tab-btn" data-value="parallel">Parallel RLC</button>
                            <button class="tab-btn" data-value="rl">RL Only</button>
                            <button class="tab-btn" data-value="rc">RC Only</button>
                        </div>
                    </div>
                </div>

                <!-- Input Signal Type -->
                <div class="form-group">
                    <label for="inputType">Input Signal</label>
                    <select id="inputType">
                        <option value="step">Step Input</option>
                        <option value="impulse">Impulse Input</option>
                        <option value="sine">Sinusoid (Sweep)</option>
                    </select>
                </div>

                <!-- Resistance -->
                <div class="form-group">
                    <label>Resistance R (Œ©): <span id="valR">10</span></label>
                    <input type="range" id="sliderR" min="1" max="100" step="1" value="10">
                </div>

                <!-- Inductance -->
                <div class="form-group" id="groupL">
                    <label>Inductance L (H): <span id="valL">0.1</span></label>
                    <input type="range" id="sliderL" min="0.01" max="1" step="0.01" value="0.1">
                </div>

                <!-- Capacitance -->
                <div class="form-group" id="groupC">
                    <label>Capacitance C (F): <span id="valC">0.001</span></label>
                    <input type="range" id="sliderC" min="0.0001" max="0.01" step="0.0001" value="0.001">
                </div>

                <!-- Voltage Input -->
                <div class="form-group">
                    <label>Input Voltage (V): <span id="valVin">10</span></label>
                    <input type="range" id="sliderVin" min="1" max="50" step="1" value="10">
                </div>

                <!-- Analysis Type -->
                <div class="form-group">
                    <label for="analysis">Analysis Type</label>
                    <select id="analysis">
                        <option value="transient">Time-Domain Response</option>
                        <option value="frequency">Frequency Response (Bode)</option>
                    </select>
                </div>

                <button id="btnSimulate" data-i18n="simulateBtn">Simulate & Analyze</button>

                <div class="badge" data-i18n="badgeTF">Transfer Function</div>
                <div class="badge" data-i18n="badgeBode">Bode Plot</div>
                <div class="badge" data-i18n="badgeResonance">Resonance</div>
            </div>

            <!-- Visualization & Analysis -->
            <div>
                <!-- Circuit Schematic -->
                <div class="card">
                    <div class="card-header">üîå Circuit Topology</div>
                    <div class="circuit-schematic">
                        <canvas id="schematicCanvas" class="schematic"></canvas>
                    </div>
                </div>

                <!-- Bode Plot & Transient Response -->
                <div class="card">
                    <div class="card-header">üìä Frequency Response (Bode Plot)</div>
                    <div class="dual-chart">
                        <div>
                            <div class="chart-label">Magnitude (dB)</div>
                            <div class="chart-container">
                                <canvas id="magnitudeChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <div class="chart-label">Phase (degrees)</div>
                            <div class="chart-container">
                                <canvas id="phaseChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Time-Domain Response -->
                <div class="card">
                    <div class="card-header">‚è±Ô∏è Time-Domain Response</div>
                    <div class="chart-container">
                        <canvas id="transientChart"></canvas>
                    </div>
                </div>

                <!-- Transfer Function & Equations -->
                <div class="card">
                    <div class="card-header">üìê Transfer Function & Differential Equations</div>
                    <div id="tfDisplay"></div>
                    <div class="info-section">
                        <h3>Governing Differential Equation</h3>
                        <p id="deDisplay"></p>
                    </div>
                    <div id="resonanceSection" class="info-section">
                        <h3>Resonance Properties</h3>
                        <div id="resonanceDisplay"></div>
                    </div>
                </div>

                <!-- Engineering Application -->
                <div class="card">
                    <div class="card-header">‚ö° Real-World Impact</div>
                    <div id="engineeringApp" class="engineering-box"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                title: "‚ö° Circuit Equations & Bode Plots",
                subtitle: "RLC circuits, transfer functions, resonance, and frequency response analysis",
                config: "‚öôÔ∏è Configuration",
                topology: "Circuit Topology",
                inputSignal: "Input Signal",
                resistance: "Resistance R (Œ©)",
                inductance: "Inductance L (H)",
                capacitance: "Capacitance C (F)",
                inputVoltage: "Input Voltage (V)",
                analysisType: "Analysis Type",
                simulateBtn: "Simulate & Analyze",
                badgeTF: "Transfer Function",
                badgeBode: "Bode Plot",
                badgeResonance: "Resonance",

                circuitDiagram: "üîå Circuit Topology",
                freqResponse: "üìä Frequency Response (Bode Plot)",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Phase (degrees)",
                timeResponse: "‚è±Ô∏è Time-Domain Response",
                tfTitle: "üìê Transfer Function & Equations",
                governingEq: "Governing Differential Equation",
                resonanceProps: "Resonance Properties",
                realWorld: "‚ö° Real-World Impact",

                // Selects
                series: "Series RLC",
                parallel: "Parallel RLC",
                rl: "RL Only (1st Order)",
                rc: "RC Only (1st Order)",
                step: "Step Input",
                impulse: "Impulse Input",
                sine: "Sinusoid (Sweep)",
                transient: "Time-Domain Response",
                frequency: "Frequency Response (Bode)",

                // Contexts
                truss: "Truss Joint Analysis",
                beam: "Beam Support Reactions",
                pulley: "Pulley & Cable Systems",
                landing: "Landing Gear Impact Forces"
            },
            pl: {
                title: "‚ö° R√≥wnania Obwod√≥w i Wykresy Bodego",
                subtitle: "Obwody RLC, transmitancje, rezonans i analiza czƒôstotliwo≈õciowa",
                config: "‚öôÔ∏è Konfiguracja",
                topology: "Topologia Obwodu",
                inputSignal: "Sygna≈Ç Wej≈õciowy",
                resistance: "Rezystancja R (Œ©)",
                inductance: "Indukcyjno≈õƒá L (H)",
                capacitance: "Pojemno≈õƒá C (F)",
                inputVoltage: "Napiƒôcie Wej≈õciowe (V)",
                analysisType: "Typ Analizy",
                simulateBtn: "Symuluj i Analizuj",
                badgeTF: "Transmitancja",
                badgeBode: "Wykres Bodego",
                badgeResonance: "Rezonans",
                circuitDiagram: "üîå Schemat Obwodu",
                freqResponse: "üìä Odpowied≈∫ Czƒôstotliwo≈õciowa",
                magLabel: "Amplituda (dB)",
                phaseLabel: "Faza (stopnie)",
                timeResponse: "‚è±Ô∏è Odpowied≈∫ Czasowa",
                tfTitle: "üìê Transmitancja i R√≥wnania",
                governingEq: "R√≥wnanie R√≥≈ºniczkowe",
                resonanceProps: "W≈Ça≈õciwo≈õci Rezonansowe",
                realWorld: "‚ö° Zastosowanie Praktyczne",
                series: "Szeregowy RLC",
                parallel: "R√≥wnoleg≈Çy RLC",
                rl: "Tylko RL (1. rzƒôdu)",
                rc: "Tylko RC (1. rzƒôdu)",
                step: "Skok Jednostkowy",
                impulse: "Impuls Diraca",
                sine: "Sinusoida",
                transient: "Analiza Czasowa",
                frequency: "Analiza Czƒôstotliwo≈õciowa"
            },
            fr: {
                title: "‚ö° √âquations de Circuit & Diagrammes de Bode",
                subtitle: "Circuits RLC, fonctions de transfert, r√©sonance et r√©ponse fr√©quentielle",
                config: "‚öôÔ∏è Configuration",
                topology: "Topologie du Circuit",
                inputSignal: "Signal d'Entr√©e",
                resistance: "R√©sistance R (Œ©)",
                inductance: "Inductance L (H)",
                capacitance: "Capacit√© C (F)",
                inputVoltage: "Tension d'Entr√©e (V)",
                analysisType: "Type d'Analyse",
                simulateBtn: "Simuler & Analyser",
                badgeTF: "Fonction de Transfert",
                badgeBode: "Diagramme de Bode",
                badgeResonance: "R√©sonance",
                circuitDiagram: "üîå Sch√©ma du Circuit",
                freqResponse: "üìä R√©ponse Fr√©quentielle",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Phase (degr√©s)",
                timeResponse: "‚è±Ô∏è R√©ponse Temporelle",
                tfTitle: "üìê Fonction de Transfert",
                governingEq: "√âquation Diff√©rentielle",
                resonanceProps: "Propri√©t√©s de R√©sonance",
                realWorld: "‚ö° Impact R√©el",
                series: "RLC S√©rie",
                parallel: "RLC Parall√®le",
                rl: "RL Seul (1er Ordre)",
                rc: "RC Seul (1er Ordre)",
                step: "√âchelon",
                impulse: "Impulsion",
                sine: "Sinuso√Øde",
                transient: "R√©ponse Temporelle",
                frequency: "R√©ponse Fr√©quentielle"
            },
            es: {
                title: "‚ö° Ecuaciones de Circuito y Diagramas de Bode",
                subtitle: "Circuitos RLC, funciones de transferencia, resonancia y an√°lisis de respuesta en frecuencia",
                config: "‚öôÔ∏è Configuraci√≥n",
                topology: "Topolog√≠a del Circuito",
                inputSignal: "Se√±al de Entrada",
                resistance: "Resistencia R (Œ©)",
                inductance: "Inductancia L (H)",
                capacitance: "Capacitancia C (F)",
                inputVoltage: "Voltaje de Entrada (V)",
                analysisType: "Tipo de An√°lisis",
                simulateBtn: "Simular y Analizar",
                badgeTF: "Funci√≥n de Transferencia",
                badgeBode: "Diagrama de Bode",
                badgeResonance: "Resonancia",
                circuitDiagram: "üîå Esquema del Circuito",
                freqResponse: "üìä Respuesta en Frecuencia",
                magLabel: "Magnitud (dB)",
                phaseLabel: "Fase (grados)",
                timeResponse: "‚è±Ô∏è Respuesta Temporal",
                tfTitle: "üìê Funci√≥n de Transferencia",
                governingEq: "Ecuaci√≥n Diferencial",
                resonanceProps: "Propiedades de Resonancia",
                realWorld: "‚ö° Impacto en el Mundo Real",
                series: "RLC Serie",
                parallel: "RLC Paralelo",
                rl: "Solo RL (1er Orden)",
                rc: "Solo RC (1er Orden)",
                step: "Entrada Escal√≥n",
                impulse: "Entrada Impulso",
                sine: "Sinusoide",
                transient: "Respuesta Temporal",
                frequency: "Respuesta en Frecuencia"
            },
            pt: {
                title: "‚ö° Equa√ß√µes de Circuito e Diagramas de Bode",
                subtitle: "Circuitos RLC, fun√ß√µes de transfer√™ncia, resson√¢ncia e an√°lise de resposta em frequ√™ncia",
                config: "‚öôÔ∏è Configura√ß√£o",
                topology: "Topologia do Circuito",
                inputSignal: "Sinal de Entrada",
                resistance: "Resist√™ncia R (Œ©)",
                inductance: "Indut√¢ncia L (H)",
                capacitance: "Capacit√¢ncia C (F)",
                inputVoltage: "Tens√£o de Entrada (V)",
                analysisType: "Tipo de An√°lise",
                simulateBtn: "Simular e Analisar",
                badgeTF: "Fun√ß√£o de Transfer√™ncia",
                badgeBode: "Diagrama de Bode",
                badgeResonance: "Resson√¢ncia",
                circuitDiagram: "üîå Esquema do Circuito",
                freqResponse: "üìä Resposta em Frequ√™ncia",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Fase (graus)",
                timeResponse: "‚è±Ô∏è Resposta Temporal",
                tfTitle: "üìê Fun√ß√£o de Transfer√™ncia",
                governingEq: "Equa√ß√£o Diferencial",
                resonanceProps: "Propriedades de Resson√¢ncia",
                realWorld: "‚ö° Impacto no Mundo Real",
                series: "RLC S√©rie",
                parallel: "RLC Paralelo",
                rl: "Apenas RL (1¬™ Ordem)",
                rc: "Apenas RC (1¬™ Ordem)",
                step: "Degrau",
                impulse: "Impulso",
                sine: "Sen√≥ide",
                transient: "Resposta Temporal",
                frequency: "Resposta em Frequ√™ncia"
            },
            de: {
                title: "‚ö° Schaltungsgleichungen & Bode-Diagramme",
                subtitle: "RLC-Schaltungen, √úbertragungsfunktionen, Resonanz und Frequenzgangsanalyse",
                config: "‚öôÔ∏è Konfiguration",
                topology: "Schaltungstopologie",
                inputSignal: "Eingangssignal",
                resistance: "Widerstand R (Œ©)",
                inductance: "Induktivit√§t L (H)",
                capacitance: "Kapazit√§t C (F)",
                inputVoltage: "Eingangsspannung (V)",
                analysisType: "Analysetyp",
                simulateBtn: "Simulieren & Analysieren",
                badgeTF: "√úbertragungsfunktion",
                badgeBode: "Bode-Diagramm",
                badgeResonance: "Resonanz",
                circuitDiagram: "üîå Schaltplan",
                freqResponse: "üìä Frequenzgang",
                magLabel: "Betrag (dB)",
                phaseLabel: "Phase (Grad)",
                timeResponse: "‚è±Ô∏è Zeitbereichsantwort",
                tfTitle: "üìê √úbertragungsfunktion",
                governingEq: "Differentialgleichung",
                resonanceProps: "Resonanzeigenschaften",
                realWorld: "‚ö° Reale Anwendungen",
                series: "RLC Serie",
                parallel: "RLC Parallel",
                rl: "Nur RL (1. Ordnung)",
                rc: "Nur RC (1. Ordnung)",
                step: "Sprungfunktion",
                impulse: "Impuls",
                sine: "Sinus",
                transient: "Zeitbereich",
                frequency: "Frequenzgang"
            },
            ua: {
                title: "‚ö° –†—ñ–≤–Ω—è–Ω–Ω—è –ö—ñ–ª —Ç–∞ –î—ñ–∞–≥—Ä–∞–º–∏ –ë–æ–¥–µ",
                subtitle: "RLC –∫–æ–ª–∞, –ø–µ—Ä–µ–¥–∞–≤–∞–ª—å–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó, —Ä–µ–∑–æ–Ω–∞–Ω—Å —Ç–∞ —á–∞—Å—Ç–æ—Ç–Ω–∏–π –∞–Ω–∞–ª—ñ–∑",
                config: "‚öôÔ∏è –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è",
                topology: "–¢–æ–ø–æ–ª–æ–≥—ñ—è –ö–æ–ª–∞",
                inputSignal: "–í—Ö—ñ–¥–Ω–∏–π –°–∏–≥–Ω–∞–ª",
                resistance: "–û–ø—ñ—Ä R (–û–º)",
                inductance: "–Ü–Ω–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å L (–ì–Ω)",
                capacitance: "–Ñ–º–Ω—ñ—Å—Ç—å C (–§)",
                inputVoltage: "–í—Ö—ñ–¥–Ω–∞ –ù–∞–ø—Ä—É–≥–∞ (–í)",
                analysisType: "–¢–∏–ø –ê–Ω–∞–ª—ñ–∑—É",
                simulateBtn: "–°–∏–º—É–ª—é–≤–∞—Ç–∏ —Ç–∞ –ê–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏",
                badgeTF: "–ü–µ—Ä–µ–¥–∞–≤–∞–ª—å–Ω–∞ –§—É–Ω–∫—Ü—ñ—è",
                badgeBode: "–î—ñ–∞–≥—Ä–∞–º–∞ –ë–æ–¥–µ",
                badgeResonance: "–†–µ–∑–æ–Ω–∞–Ω—Å",
                circuitDiagram: "üîå –°—Ö–µ–º–∞ –ö–æ–ª–∞",
                freqResponse: "üìä –ß–∞—Å—Ç–æ—Ç–Ω–∞ –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞",
                magLabel: "–ê–º–ø–ª—ñ—Ç—É–¥–∞ (–¥–ë)",
                phaseLabel: "–§–∞–∑–∞ (–≥—Ä–∞–¥—É—Å–∏)",
                timeResponse: "‚è±Ô∏è –ß–∞—Å–æ–≤–∞ –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞",
                tfTitle: "üìê –ü–µ—Ä–µ–¥–∞–≤–∞–ª—å–Ω–∞ –§—É–Ω–∫—Ü—ñ—è",
                governingEq: "–î–∏—Ñ–µ—Ä–µ–Ω—Ü—ñ–∞–ª—å–Ω–µ –†—ñ–≤–Ω—è–Ω–Ω—è",
                resonanceProps: "–†–µ–∑–æ–Ω–∞–Ω—Å–Ω—ñ –í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ",
                realWorld: "‚ö° –ü—Ä–∞–∫—Ç–∏—á–Ω–µ –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è",
                series: "–ü–æ—Å–ª—ñ–¥–æ–≤–Ω–µ RLC",
                parallel: "–ü–∞—Ä–∞–ª–µ–ª—å–Ω–µ RLC",
                rl: "–¢—ñ–ª—å–∫–∏ RL",
                rc: "–¢—ñ–ª—å–∫–∏ RC",
                step: "–°—Ö–æ–¥–∏–Ω–∫–∞",
                impulse: "–Ü–º–ø—É–ª—å—Å",
                sine: "–°–∏–Ω—É—Å–æ—ó–¥–∞",
                transient: "–ß–∞—Å–æ–≤–∏–π –ê–Ω–∞–ª—ñ–∑",
                frequency: "–ß–∞—Å—Ç–æ—Ç–Ω–∏–π –ê–Ω–∞–ª—ñ–∑"
            },
            be: {
                title: "‚ö° –†–∞–∫–Ω–∞–Ω–Ω—ñ –õ–∞–Ω—Ü—É–≥–æ—û —ñ –î—ã—è–≥—Ä–∞–º—ã –ë–æ–¥—ç",
                subtitle: "RLC –ª–∞–Ω—Ü—É–≥—ñ, –ø–µ—Ä–∞–¥–∞—Ç–∫–∞–≤—ã—è —Ñ—É–Ω–∫—Ü—ã—ñ, —Ä—ç–∑–∞–Ω–∞–Ω—Å —ñ —á–∞—Å—Ç–æ—Ç–Ω—ã –∞–Ω–∞–ª—ñ–∑",
                config: "‚öôÔ∏è –ö–∞–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ã—è",
                topology: "–¢–∞–ø–∞–ª–æ–≥—ñ—è –õ–∞–Ω—Ü—É–≥–∞",
                inputSignal: "–£–≤–∞—Ö–æ–¥–Ω—ã –°—ñ–≥–Ω–∞–ª",
                resistance: "–°—É–ø—Ä–∞—Ü—ñ—û–ª–µ–Ω–Ω–µ R (–û–º)",
                inductance: "–Ü–Ω–¥—É–∫—Ç—ã—û–Ω–∞—Å—Ü—å L (–ì–Ω)",
                capacitance: "–Å–º—ñ—Å—Ç–∞—Å—Ü—å C (–§)",
                inputVoltage: "–£–≤–∞—Ö–æ–¥–Ω–∞–µ –ù–∞–ø—Ä—É–∂–∞–Ω–Ω–µ (–í)",
                analysisType: "–¢—ã–ø –ê–Ω–∞–ª—ñ–∑—É",
                simulateBtn: "–°—ñ–º—É–ª—è–≤–∞—Ü—å —ñ –ê–Ω–∞–ª—ñ–∑–∞–≤–∞—Ü—å",
                badgeTF: "–ü–µ—Ä–∞–¥–∞—Ç–∫–∞–≤–∞—è –§—É–Ω–∫—Ü—ã—è",
                badgeBode: "–î—ã—è–≥—Ä–∞–º–∞ –ë–æ–¥—ç",
                badgeResonance: "–†—ç–∑–∞–Ω–∞–Ω—Å",
                circuitDiagram: "üîå –°—Ö–µ–º–∞ –õ–∞–Ω—Ü—É–≥–∞",
                freqResponse: "üìä –ß–∞—Å—Ç–æ—Ç–Ω–∞—è –•–∞—Ä–∞–∫—Ç–∞—Ä—ã—Å—Ç—ã–∫–∞",
                magLabel: "–ê–º–ø–ª—ñ—Ç—É–¥–∞ (–¥–ë)",
                phaseLabel: "–§–∞–∑–∞ (–≥—Ä–∞–¥—É—Å—ã)",
                timeResponse: "‚è±Ô∏è –ß–∞—Å–∞–≤–∞—è –•–∞—Ä–∞–∫—Ç–∞—Ä—ã—Å—Ç—ã–∫–∞",
                tfTitle: "üìê –ü–µ—Ä–∞–¥–∞—Ç–∫–∞–≤–∞—è –§—É–Ω–∫—Ü—ã—è",
                governingEq: "–î—ã—Ñ–µ—Ä—ç–Ω—Ü—ã—è–ª—å–Ω–∞–µ –†–∞—û–Ω–∞–Ω–Ω–µ",
                resonanceProps: "–†—ç–∑–∞–Ω–∞–Ω—Å–Ω—ã—è –é–ª–∞—Å—Ü—ñ–≤–∞—Å—Ü—ñ",
                realWorld: "‚ö° –ü—Ä–∞–∫—Ç—ã—á–Ω–∞–µ –£–∂—ã–≤–∞–Ω–Ω–µ",
                series: "–ü–∞—Å–ª—è–¥–æ—û–Ω–∞–µ RLC",
                parallel: "–ü–∞—Ä–∞–ª–µ–ª—å–Ω–∞–µ RLC",
                rl: "–¢–æ–ª—å–∫—ñ RL",
                rc: "–¢–æ–ª—å–∫—ñ RC",
                step: "–ü—Ä—ã—Å—Ç—É–ø–∫–∞",
                impulse: "–Ü–º–ø—É–ª—å—Å",
                sine: "–°—ñ–Ω—É—Å–æ—ñ–¥–∞",
                transient: "–ß–∞—Å–∞–≤—ã –ê–Ω–∞–ª—ñ–∑",
                frequency: "–ß–∞—Å—Ç–æ—Ç–Ω—ã –ê–Ω–∞–ª—ñ–∑"
            }
        };

        const app = {
            magChart: null,
            phaseChart: null,
            transientChart: null,
            schematicCtx: null,
            state: {
                topology: 'series',
                inputType: 'step',
                R: 10,
                L: 0.1,
                C: 0.001,
                Vin: 10,
                analysis: 'transient'
            },
            lang: 'en',
            theme: 'light',
            initialized: false,

            // setTheme and setLang removed - handled by site.js

            // Calculate transfer function parameters
            getTransferFunction: () => {
                const R = app.state.R;
                const L = app.state.L;
                const C = app.state.C;
                const topology = app.state.topology;

                let tf = {};

                if (topology === 'series') {
                    // Series RLC: H(s) = 1 / (LCs^2 + RCs + 1)
                    tf.b = [1];
                    tf.a = [L * C, R * C, 1];
                    tf.wn = Math.sqrt(1 / (L * C)); // Natural frequency
                    tf.zeta = (R * C) / (2 * Math.sqrt(L / C)); // Damping ratio
                    tf.wd = tf.wn * Math.sqrt(Math.max(0, 1 - tf.zeta * tf.zeta)); // Damped frequency
                } else if (topology === 'parallel') {
                    // Parallel RLC: H(s) = R / (1 + RCs + LRs + LCs^2) simplified
                    tf.b = [1];
                    tf.a = [L * C, R * C, 1];
                    tf.wn = Math.sqrt(1 / (L * C));
                    tf.zeta = (R * C) / (2 * Math.sqrt(L / C));
                    tf.wd = tf.wn * Math.sqrt(Math.max(0, 1 - tf.zeta * tf.zeta));
                } else if (topology === 'rl') {
                    // RL: H(s) = 1 / (Ls + R)
                    tf.b = [1];
                    tf.a = [L, R];
                    tf.wn = R / L;
                    tf.zeta = 1;
                    tf.wd = 0;
                } else if (topology === 'rc') {
                    // RC: H(s) = 1 / (RCs + 1)
                    tf.b = [1];
                    tf.a = [R * C, 1];
                    tf.wn = 1 / (R * C);
                    tf.zeta = 1;
                    tf.wd = 0;
                }

                return tf;
            },

            // Evaluate transfer function at complex frequency s = jw
            evaluateTF: (tf, w) => {
                // Numerator B(s) = b[0]*s^m + ... (Here b is just [1], so B(s) = 1)
                // Denominator A(s) = a[0]*s^n + a[1]*s^(n-1) + ... + a[n]
                
                // Evaluate Polynomial P(s) at s = jw
                const evalPoly = (coeffs, w) => {
                    let real = 0;
                    let imag = 0;
                    const n = coeffs.length - 1;
                    
                    for (let i = 0; i <= n; i++) {
                        const power = n - i;
                        const coeff = coeffs[i];
                        // (jw)^k
                        // k=0: 1
                        // k=1: jw
                        // k=2: -w^2
                        // k=3: -jw^3
                        // k=4: w^4
                        const w_pow = Math.pow(w, power);
                        if (power % 4 === 0) real += coeff * w_pow;
                        else if (power % 4 === 1) imag += coeff * w_pow;
                        else if (power % 4 === 2) real -= coeff * w_pow;
                        else if (power % 4 === 3) imag -= coeff * w_pow;
                    }
                    return { real, imag };
                };

                const num = evalPoly(tf.b, w);
                const den = evalPoly(tf.a, w);

                // Complex division: num / den
                const den_mag_sq = den.real * den.real + den.imag * den.imag;
                const real = (num.real * den.real + num.imag * den.imag) / den_mag_sq;
                const imag = (num.imag * den.real - num.real * den.imag) / den_mag_sq;

                const magnitude = Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real) * 180 / Math.PI;

                return { magnitude, phase };
            },

            // Generate time-domain response
            generateTransientResponse: () => {
                const tf = app.getTransferFunction();
                const t_end = 1;
                const dt = 0.001;
                const t_points = Math.ceil(t_end / dt);
                const response = [];
                const time = [];

                const K = tf.b[0] / tf.a[tf.a.length - 1];

                for (let i = 0; i < t_points; i++) {
                    const t = i * dt;
                    time.push(t);

                    let y = K * app.state.Vin;
                    const zeta = tf.zeta;

                    if (zeta > 1) {
                        // Overdamped
                        const r1 = -tf.wn * (zeta - Math.sqrt(zeta * zeta - 1));
                        const r2 = -tf.wn * (zeta + Math.sqrt(zeta * zeta - 1));
                        y *= (1 + (r2 * Math.exp(r1 * t) - r1 * Math.exp(r2 * t)) / (r1 - r2));
                    } else if (zeta === 1) {
                        // Critically damped
                        y *= (1 - Math.exp(-tf.wn * t) * (1 + tf.wn * t));
                    } else {
                        // Underdamped
                        const decay = Math.exp(-zeta * tf.wn * t);
                        const phase = Math.atan2(tf.wd, zeta * tf.wn);
                        y *= (1 - decay * Math.cos(tf.wd * t - phase) / Math.cos(phase));
                    }

                    response.push(y);
                }

                return { time, response };
            },

            init: () => {
                const schematicCanvas = document.getElementById('schematicCanvas');
                app.schematicCtx = schematicCanvas ? schematicCanvas.getContext('2d') : null;

                // Tab handling for Topology
                document.querySelectorAll('#topologyTabs .tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('#topologyTabs .tab-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        app.state.topology = e.target.getAttribute('data-value');
                        app.updateFormDisplay();
                        app.update();
                    });
                });

                document.getElementById('inputType').addEventListener('change', (e) => {
                    app.state.inputType = e.target.value;
                    app.update();
                });

                document.getElementById('analysis').addEventListener('change', (e) => {
                    app.state.analysis = e.target.value;
                    app.update();
                });

                document.getElementById('sliderR').addEventListener('input', (e) => {
                    app.state.R = parseFloat(e.target.value);
                    document.getElementById('valR').textContent = app.state.R.toFixed(1);
                    app.update();
                });

                document.getElementById('sliderL').addEventListener('input', (e) => {
                    app.state.L = parseFloat(e.target.value);
                    document.getElementById('valL').textContent = app.state.L.toFixed(3);
                    app.update();
                });

                document.getElementById('sliderC').addEventListener('input', (e) => {
                    app.state.C = parseFloat(e.target.value);
                    document.getElementById('valC').textContent = app.state.C.toFixed(5);
                    app.update();
                });

                document.getElementById('sliderVin').addEventListener('input', (e) => {
                    app.state.Vin = parseFloat(e.target.value);
                    document.getElementById('valVin').textContent = app.state.Vin.toFixed(1);
                    app.update();
                });

                // Listen for site.js events
                window.addEventListener('themechange', (e) => {
                    app.theme = e.detail.theme;
                    if (app.initialized) {
                        app.updateChartTheme();
                        app.update();
                    }
                });
                
                window.addEventListener('langchange', (e) => {
                    app.lang = e.detail.lang;
                    app.updateTranslations();
                    if (app.initialized) app.update();
                });

                // Initial sync
                app.theme = document.documentElement.getAttribute('data-theme') || 'light';
                app.lang = document.documentElement.getAttribute('lang') || 'en';
                app.updateTranslations();

                app.updateFormDisplay();
                app.initCharts();
                app.initialized = true;
                app.update();
                if (window.lucide) lucide.createIcons();
            },

            updateTranslations: () => {
                const t = translations[app.lang];
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) el.innerHTML = t[key];
                });
            },

            updateFormDisplay: () => {
                const t = app.state.topology;
                const showL = t === 'series' || t === 'parallel' || t === 'rl';
                const showC = t === 'series' || t === 'parallel' || t === 'rc';
                document.getElementById('groupL').classList.toggle('hidden', !showL);
                document.getElementById('groupC').classList.toggle('hidden', !showC);
            },

            hexToRgba: (hex, alpha) => {
                let r = 0, g = 0, b = 0;
                if (hex.startsWith('rgb')) return hex.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                if (hex.length === 4) {
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) {
                    r = parseInt(hex.slice(1, 3), 16);
                    g = parseInt(hex.slice(3, 5), 16);
                    b = parseInt(hex.slice(5, 7), 16);
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },

            getVar: (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim(),

            getChartColors: () => {
                const primary = app.getVar('--primary');
                const accent = app.getVar('--accent');
                const success = app.getVar('--success');

                return {
                    text: app.getVar('--text-light'),
                    grid: app.getVar('--border'),
                    primary: primary,
                    primaryBg: app.hexToRgba(primary, 0.1),
                    secondary: accent,
                    secondaryBg: app.hexToRgba(accent, 0.6),
                    success: success,
                    successBg: app.hexToRgba(success, 0.1)
                };
            },

            updateChartTheme: () => {
                const colors = app.getChartColors();
                
                const updateChart = (chart) => {
                    if (!chart) return;
                    
                    if (chart.options.scales.x) {
                        chart.options.scales.x.title.color = colors.text;
                        chart.options.scales.x.grid.color = colors.grid;
                        chart.options.scales.x.ticks.color = colors.text;
                    }
                    if (chart.options.scales.y) {
                        chart.options.scales.y.title.color = colors.text;
                        chart.options.scales.y.grid.color = colors.grid;
                        chart.options.scales.y.ticks.color = colors.text;
                    }
                    
                    if (chart.options.plugins.legend) {
                        chart.options.plugins.legend.labels.color = colors.text;
                    }
                };

                updateChart(app.magChart);
                updateChart(app.phaseChart);
                updateChart(app.transientChart);

                if (app.magChart) {
                    app.magChart.data.datasets[0].borderColor = colors.primary;
                    app.magChart.data.datasets[0].backgroundColor = colors.primaryBg;
                    app.magChart.update();
                }
                if (app.phaseChart) {
                    app.phaseChart.data.datasets[0].borderColor = colors.secondary;
                    app.phaseChart.data.datasets[0].backgroundColor = colors.secondaryBg;
                    app.phaseChart.update();
                }
                if (app.transientChart) {
                    app.transientChart.data.datasets[0].borderColor = colors.success;
                    app.transientChart.data.datasets[0].backgroundColor = colors.successBg;
                    app.transientChart.update();
                }
            },

            initCharts: () => {
                if (!window.Chart) return;
                const magnitudeCanvas = document.getElementById('magnitudeChart');
                const phaseCanvas = document.getElementById('phaseChart');
                const transientCanvas = document.getElementById('transientChart');
                if (!magnitudeCanvas || !phaseCanvas || !transientCanvas) return;

                const colors = app.getChartColors();
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true, labels: { color: colors.text } } },
                    scales: {
                        x: {
                            title: { display: true, text: 'Frequency (Hz)', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        },
                        y: {
                            title: { display: true, text: 'Value', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        }
                    }
                };

                const magCtx = document.getElementById('magnitudeChart').getContext('2d');
                app.magChart = new Chart(magCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Magnitude', data: [], borderColor: colors.primary, backgroundColor: colors.primaryBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Frequency (Hz) - Log Scale', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: translations[app.lang]?.magLabel || 'Gain (dB)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });

                const phaseCtx = document.getElementById('phaseChart').getContext('2d');
                app.phaseChart = new Chart(phaseCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Phase', data: [], borderColor: colors.secondary, backgroundColor: colors.secondaryBg, borderWidth: 2, fill: false, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Frequency (Hz) - Log Scale', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: translations[app.lang]?.phaseLabel || 'Phase (degrees)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });

                const transCtx = document.getElementById('transientChart').getContext('2d');
                app.transientChart = new Chart(transCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Output', data: [], borderColor: colors.success, backgroundColor: colors.successBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Time (s)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: 'Output Voltage (V)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });
            },

            update: () => {
                app.drawSchematic();
                if (app.magChart && app.phaseChart) app.generateBodePlot();
                if (app.transientChart) app.generateTransientPlot();
                app.displayTransferFunction();
                app.displayEngineering();
            },

            drawSchematic: () => {
                const canvas = document.getElementById('schematicCanvas');
                const ctx = app.schematicCtx;
                if (!ctx) return;

                const w = canvas.clientWidth;
                const h = canvas.clientHeight;
                canvas.width = w;
                canvas.height = h;

                // Use CSS variables for colors
                const bgColor = app.getVar('--grid-bg');
                const strokeColor = app.getVar('--text-main');
                const primaryColor = app.getVar('--primary');
                const textColor = app.getVar('--text-light');

                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, w, h);

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;

                ctx.font = 'bold 14px Inter';
                ctx.fillStyle = primaryColor;

                const t = app.state.topology;
                if (t === 'series') {
                    ctx.fillText(translations[app.lang]?.series || 'Series RLC Circuit', w / 2 - 60, 30);
                    // Simple representation
                    ctx.beginPath();
                    ctx.moveTo(50, 100);
                    ctx.lineTo(w - 50, 100);
                    ctx.stroke();

                    // Components (simplified boxes)
                    ctx.fillStyle = bgColor;

                    // R
                    ctx.fillRect(80, 90, 40, 20);
                    ctx.strokeRect(80, 90, 40, 20);

                    // L
                    ctx.fillRect(180, 90, 40, 20);
                    ctx.strokeRect(180, 90, 40, 20);

                    // C
                    ctx.fillRect(280, 90, 40, 20);
                    ctx.strokeRect(280, 90, 40, 20);

                    ctx.fillStyle = primaryColor;
                    ctx.fillText('R', 95, 80);
                    ctx.fillText('L', 195, 80);
                    ctx.fillText('C', 295, 80);
                } else if (t === 'parallel') {
                    ctx.fillText(translations[app.lang]?.parallel || 'Parallel RLC Circuit', w / 2 - 70, 30);
                    ctx.font = '12px Inter';
                    ctx.fillStyle = textColor;
                    ctx.fillText('(All branches share voltage)', w / 2 - 80, 50);

                    // Draw Parallel Lines
                    ctx.beginPath();
                    ctx.moveTo(50, 100); ctx.lineTo(350, 100);
                    ctx.moveTo(50, 200); ctx.lineTo(350, 200);

                    // Branches
                    ctx.moveTo(100, 100); ctx.lineTo(100, 200); // R
                    ctx.moveTo(200, 100); ctx.lineTo(200, 200); // L
                    ctx.moveTo(300, 100); ctx.lineTo(300, 200); // C
                    ctx.strokeStyle = strokeColor;
                    ctx.stroke();

                    ctx.fillStyle = primaryColor;
                    ctx.font = 'bold 14px Inter';
                    ctx.fillText('R', 105, 95);
                    ctx.fillText('L', 205, 95);
                    ctx.fillText('C', 305, 95);

                } else if (t === 'rl') {
                    ctx.fillText(translations[app.lang]?.rl || 'RL Circuit', w / 2 - 40, 30);

                    ctx.beginPath();
                    ctx.moveTo(50, 100); ctx.lineTo(250, 100);
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(100, 90, 40, 20); // R
                    ctx.strokeRect(100, 90, 40, 20);
                    ctx.fillRect(200, 90, 40, 20); // L
                    ctx.strokeRect(200, 90, 40, 20);
                    ctx.stroke();

                    ctx.fillStyle = primaryColor;
                    ctx.fillText('R', 115, 80);
                    ctx.fillText('L', 215, 80);
                } else if (t === 'rc') {
                    ctx.fillText(translations[app.lang]?.rc || 'RC Circuit', w / 2 - 40, 30);

                    ctx.beginPath();
                    ctx.moveTo(50, 100); ctx.lineTo(250, 100);
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(100, 90, 40, 20); // R
                    ctx.strokeRect(100, 90, 40, 20);
                    ctx.fillRect(200, 90, 40, 20); // C
                    ctx.strokeRect(200, 90, 40, 20);
                    ctx.stroke();

                    ctx.fillStyle = primaryColor;
                    ctx.fillText('R', 115, 80);
                    ctx.fillText('C', 215, 80);
                }

                ctx.font = '12px Inter';
                ctx.fillStyle = textColor;
                ctx.fillText(`R=${app.state.R.toFixed(1)}Œ©`, 50, 240);
                if (t !== 'rc') ctx.fillText(`L=${app.state.L.toFixed(3)}H`, 50, 260);
                if (t !== 'rl') ctx.fillText(`C=${app.state.C.toFixed(5)}F`, 50, 280);
                ctx.fillText(`Vin=${app.state.Vin.toFixed(1)}V`, 50, 300);
            },

            generateBodePlot: () => {
                if (!app.magChart || !app.phaseChart) return;
                const tf = app.getTransferFunction();
                const freqs = [];
                const mags = [];
                const phases = [];

                for (let i = 0.1; i <= 1000; i *= 1.1) {
                    const w = 2 * Math.PI * i;
                    const response = app.evaluateTF(tf, w);
                    const magdB = 20 * Math.log10(Math.max(response.magnitude, 0.001));

                    freqs.push(i.toFixed(1));
                    mags.push(magdB);
                    phases.push(response.phase);
                }

                app.magChart.data.labels = freqs;
                app.magChart.data.datasets[0].data = mags;
                app.magChart.update();

                app.phaseChart.data.labels = freqs;
                app.phaseChart.data.datasets[0].data = phases;
                app.phaseChart.update();
            },

            generateTransientPlot: () => {
                if (!app.transientChart) return;
                const resp = app.generateTransientResponse();

                app.transientChart.data.labels = resp.time.map(t => t.toFixed(3));
                app.transientChart.data.datasets[0].data = resp.response;
                app.transientChart.update();
            },

            displayTransferFunction: () => {
                const tf = app.getTransferFunction();
                const t = app.state.topology;

                let tfStr = '';
                let deStr = '';

                if (t === 'series') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s¬≤ + ${app.state.R.toFixed(1)}s + ${(1 / app.state.C).toFixed(1)})`;
                    deStr = `L¬∑d¬≤V/dt¬≤ + R¬∑dV/dt + (1/C)¬∑V = Vin`;
                } else if (t === 'parallel') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s¬≤ + ${app.state.R.toFixed(1)}s + ${(1 / app.state.C).toFixed(1)})`;
                    deStr = `L¬∑d¬≤I/dt¬≤ + R¬∑dI/dt + (1/C)¬∑I = dVin/dt`;
                } else if (t === 'rl') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s + ${app.state.R.toFixed(1)})`;
                    deStr = `L¬∑dI/dt + R¬∑I = Vin`;
                } else if (t === 'rc') {
                    tfStr = `H(s) = 1 / (${app.state.R.toFixed(1)}¬∑${app.state.C.toFixed(5)}¬∑s + 1)`;
                    deStr = `RC¬∑dV/dt + V = Vin`;
                }

                document.getElementById('tfDisplay').innerHTML = `<div class="formula"><strong>Transfer Function:</strong><br/>${tfStr}</div>`;
                document.getElementById('deDisplay').textContent = deStr;

                // Resonance info
                if (t === 'series' || t === 'parallel') {
                    const wn = tf.wn;
                    const fn = wn / (2 * Math.PI);
                    const Q = wn / (app.state.R / app.state.L);
                    const BW = wn / Q;

                    let resHTML = `
                        <div class="parameter-box">
                            <strong>Natural Frequency (f‚ÇÄ):</strong> ${fn.toFixed(2)} Hz
                        </div>
                        <div class="parameter-box">
                            <strong>Damping Ratio (Œ∂):</strong> ${tf.zeta.toFixed(3)}
                        </div>
                        <div class="parameter-box">
                            <strong>Quality Factor (Q):</strong> ${Q.toFixed(3)}
                        </div>
                        <div class="parameter-box">
                            <strong>Bandwidth:</strong> ${BW.toFixed(2)} rad/s
                        </div>
                    `;
                    document.getElementById('resonanceDisplay').innerHTML = resHTML;
                } else {
                    const tau = app.state.R * app.state.C || app.state.L / app.state.R;
                    document.getElementById('resonanceDisplay').innerHTML = `<div class="parameter-box"><strong>Time Constant (œÑ):</strong> ${tau.toFixed(4)} s</div>`;
                }
            },

            displayEngineering: () => {
                let html = '';
                const zeta = app.getTransferFunction().zeta;
                const t = app.state.topology;

                if (t === 'series') {
                    if (zeta > 1) {
                        html = '<strong>‚ö†Ô∏è Overdamped Response:</strong> Slow response, no overshoot. Used in applications requiring smooth transitions (power supplies, audio filters).';
                    } else if (Math.abs(zeta - 1) < 0.01) {
                        html = '<strong>‚úì Critically Damped:</strong> Fastest response without overshoot. Ideal for instrumentation and control systems.';
                    } else {
                        html = `<strong>üîÑ Underdamped (Oscillatory):</strong> Overshoot ~${(100 * Math.exp(-Math.PI * zeta / Math.sqrt(1 - zeta * zeta))).toFixed(0)}%. Used in circuits requiring faster settling (switched-mode PSUs).`;
                    }
                } else if (t === 'rl' || t === 'rc') {
                    html = '<strong>1st Order Response:</strong> No resonance peak. Single time constant determines response speed. Common in filters and voltage regulators.';
                } else {
                    html = '<strong>Parallel RLC:</strong> Current-mode analysis. Used in impedance matching and tuned circuits.';
                }

                html += `<p style="margin-top: 12px; color: var(--text-main);">Current damping ratio Œ∂ = ${zeta.toFixed(3)}. Adjust R, L, C sliders to modify circuit response.</p>`;

                document.getElementById('engineeringApp').innerHTML = html;
            }
        };

        window.onload = app.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>