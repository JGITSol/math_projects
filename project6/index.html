<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Equations & Bode Plots | Applied Mathematics</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
</head>

<body class="project-page">
    <div class="container">
        <header>
            <div class="header-content">
                <a href="../index.html" class="back-link">
                    <i data-lucide="arrow-left"></i> Back to Hub
                </a>
                <h1 data-i18n="title">Circuit Equations & Bode Plots</h1>
                <p class="subtitle" data-i18n="subtitle">RLC circuits, transfer functions, resonance, and frequency response analysis</p>
            </div>
        </header>

        <div class="grid">
            <!-- Control Panel -->
            <div class="card">
                <div class="card-header"><i data-lucide="settings-2" style="margin-right: 8px;"></i> <span data-i18n="config">Configuration</span></div>

                <!-- Circuit Topology -->
                <div class="form-group">
                    <label data-i18n="topology">Circuit Topology</label>
                    <div class="tab-container" id="topologyTabs">
                        <div class="tab-header">
                            <button class="tab-btn active" data-value="series" data-i18n="series">Series RLC</button>
                            <button class="tab-btn" data-value="parallel" data-i18n="parallel">Parallel RLC</button>
                            <button class="tab-btn" data-value="rl" data-i18n="rl">RL Only</button>
                            <button class="tab-btn" data-value="rc" data-i18n="rc">RC Only</button>
                        </div>
                    </div>
                </div>

                <!-- Input Signal Type -->
                <div class="form-group">
                    <label for="inputType" data-i18n="inputSignal">Input Signal</label>
                    <select id="inputType">
                        <option value="step" data-i18n="step">Step Input</option>
                        <option value="impulse" data-i18n="impulse">Impulse Input</option>
                        <option value="sine" data-i18n="sine">Sinusoid (Sweep)</option>
                    </select>
                </div>

                <!-- Resistance -->
                <div class="form-group">
                    <label><span data-i18n="resistance">Resistance R (Ω)</span>: <span id="valR">10</span></label>
                    <input type="range" id="sliderR" min="1" max="100" step="1" value="10">
                </div>

                <!-- Inductance -->
                <div class="form-group" id="groupL">
                    <label><span data-i18n="inductance">Inductance L (H)</span>: <span id="valL">0.1</span></label>
                    <input type="range" id="sliderL" min="0.01" max="1" step="0.01" value="0.1">
                </div>

                <!-- Capacitance -->
                <div class="form-group" id="groupC">
                    <label><span data-i18n="capacitance">Capacitance C (F)</span>: <span id="valC">0.001</span></label>
                    <input type="range" id="sliderC" min="0.0001" max="0.01" step="0.0001" value="0.001">
                </div>

                <!-- Voltage Input -->
                <div class="form-group">
                    <label><span data-i18n="inputVoltage">Input Voltage (V)</span>: <span id="valVin">10</span></label>
                    <input type="range" id="sliderVin" min="1" max="50" step="1" value="10">
                </div>

                <!-- Analysis Type -->
                <div class="form-group">
                    <label for="analysis" data-i18n="analysisType">Analysis Type</label>
                    <select id="analysis">
                        <option value="transient" data-i18n="transient">Time-Domain Response</option>
                        <option value="frequency" data-i18n="frequency">Frequency Response (Bode)</option>
                    </select>
                </div>

                <button id="btnSimulate" data-i18n="simulateBtn">Simulate & Analyze</button>

                <div class="badge" data-i18n="badgeTF">Transfer Function</div>
                <div class="badge" data-i18n="badgeBode">Bode Plot</div>
                <div class="badge" data-i18n="badgeResonance">Resonance</div>
            </div>

            <!-- Visualization & Analysis -->
            <div>
                <!-- Circuit Schematic -->
                <div class="card">
                    <div class="card-header">Circuit Topology</div>
                    <div class="circuit-schematic">
                        <canvas id="schematicCanvas" class="schematic"></canvas>
                    </div>
                </div>

                <!-- Bode Plot & Transient Response -->
                <div class="card">
                    <div class="card-header">Frequency Response (Bode Plot)</div>
                    <div class="dual-chart">
                        <div>
                            <div class="chart-label">Magnitude (dB)</div>
                            <div class="chart-container">
                                <canvas id="magnitudeChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <div class="chart-label">Phase (degrees)</div>
                            <div class="chart-container">
                                <canvas id="phaseChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Time-Domain Response -->
                <div class="card">
                    <div class="card-header">Time-Domain Response</div>
                    <div class="chart-container">
                        <canvas id="transientChart"></canvas>
                    </div>
                </div>

                <!-- Transfer Function & Equations -->
                <div class="card">
                    <div class="card-header">Transfer Function & Differential Equations</div>
                    <div id="tfDisplay"></div>
                    <div class="info-section">
                        <h3>Governing Differential Equation</h3>
                        <p id="deDisplay"></p>
                    </div>
                    <div id="resonanceSection" class="info-section">
                        <h3>Resonance Properties</h3>
                        <div id="resonanceDisplay"></div>
                    </div>
                </div>

                <!-- Engineering Application -->
                <div class="card">
                    <div class="card-header">Real-World Impact</div>
                    <div id="engineeringApp" class="engineering-box"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                title: "Circuit Equations & Bode Plots",
                subtitle: "RLC circuits, transfer functions, resonance, and frequency response analysis",
                config: "Configuration",
                topology: "Circuit Topology",
                inputSignal: "Input Signal",
                resistance: "Resistance R (Ω)",
                inductance: "Inductance L (H)",
                capacitance: "Capacitance C (F)",
                inputVoltage: "Input Voltage (V)",
                analysisType: "Analysis Type",
                simulateBtn: "Simulate & Analyze",
                badgeTF: "Transfer Function",
                badgeBode: "Bode Plot",
                badgeResonance: "Resonance",

                circuitDiagram: "Circuit Topology",
                freqResponse: "Frequency Response (Bode Plot)",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Phase (degrees)",
                timeResponse: "Time-Domain Response",
                tfTitle: "Transfer Function & Equations",
                governingEq: "Governing Differential Equation",
                resonanceProps: "Resonance Properties",
                realWorld: "Real-World Impact",

                // Selects
                series: "Series RLC",
                parallel: "Parallel RLC",
                rl: "RL Only (1st Order)",
                rc: "RC Only (1st Order)",
                step: "Step Input",
                impulse: "Impulse Input",
                sine: "Sinusoid (Sweep)",
                transient: "Time-Domain Response",
                frequency: "Frequency Response (Bode)",

                // Contexts
                truss: "Truss Joint Analysis",
                beam: "Beam Support Reactions",
                pulley: "Pulley & Cable Systems",
                landing: "Landing Gear Impact Forces"
            },
            pl: {
                title: "Równania Obwodów i Wykresy Bodego",
                subtitle: "Obwody RLC, transmitancje, rezonans i analiza częstotliwościowa",
                config: "Konfiguracja",
                topology: "Topologia Obwodu",
                inputSignal: "Sygnał Wejściowy",
                resistance: "Rezystancja R (Ω)",
                inductance: "Indukcyjność L (H)",
                capacitance: "Pojemność C (F)",
                inputVoltage: "Napięcie Wejściowe (V)",
                analysisType: "Typ Analizy",
                simulateBtn: "Symuluj i Analizuj",
                badgeTF: "Transmitancja",
                badgeBode: "Wykres Bodego",
                badgeResonance: "Rezonans",
                circuitDiagram: "Schemat Obwodu",
                freqResponse: "Odpowiedź Częstotliwościowa",
                magLabel: "Amplituda (dB)",
                phaseLabel: "Faza (stopnie)",
                timeResponse: "Odpowiedź Czasowa",
                tfTitle: "Transmitancja i Równania",
                governingEq: "Równanie Różniczkowe",
                resonanceProps: "Właściwości Rezonansowe",
                realWorld: "Zastosowanie Praktyczne",
                series: "Szeregowy RLC",
                parallel: "Równoległy RLC",
                rl: "Tylko RL (1. rzędu)",
                rc: "Tylko RC (1. rzędu)",
                step: "Skok Jednostkowy",
                impulse: "Impuls Diraca",
                sine: "Sinusoida",
                transient: "Analiza Czasowa",
                frequency: "Analiza Częstotliwościowa"
            },
            fr: {
                title: "Équations de Circuit & Diagrammes de Bode",
                subtitle: "Circuits RLC, fonctions de transfert, résonance et réponse fréquentielle",
                config: "Configuration",
                topology: "Topologie du Circuit",
                inputSignal: "Signal d'Entrée",
                resistance: "Résistance R (Ω)",
                inductance: "Inductance L (H)",
                capacitance: "Capacité C (F)",
                inputVoltage: "Tension d'Entrée (V)",
                analysisType: "Type d'Analyse",
                simulateBtn: "Simuler & Analyser",
                badgeTF: "Fonction de Transfert",
                badgeBode: "Diagramme de Bode",
                badgeResonance: "Résonance",
                circuitDiagram: "Schéma du Circuit",
                freqResponse: "Réponse Fréquentielle",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Phase (degrés)",
                timeResponse: "Réponse Temporelle",
                tfTitle: "Fonction de Transfert",
                governingEq: "Équation Différentielle",
                resonanceProps: "Propriétés de Résonance",
                realWorld: "Impact Réel",
                series: "RLC Série",
                parallel: "RLC Parallèle",
                rl: "RL Seul (1er Ordre)",
                rc: "RC Seul (1er Ordre)",
                step: "Échelon",
                impulse: "Impulsion",
                sine: "Sinusoïde",
                transient: "Réponse Temporelle",
                frequency: "Réponse Fréquentielle"
            },
            es: {
                title: "Ecuaciones de Circuito y Diagramas de Bode",
                subtitle: "Circuitos RLC, funciones de transferencia, resonancia y análisis de respuesta en frecuencia",
                config: "Configuración",
                topology: "Topología del Circuito",
                inputSignal: "Señal de Entrada",
                resistance: "Resistencia R (Ω)",
                inductance: "Inductancia L (H)",
                capacitance: "Capacitancia C (F)",
                inputVoltage: "Voltaje de Entrada (V)",
                analysisType: "Tipo de Análisis",
                simulateBtn: "Simular y Analizar",
                badgeTF: "Función de Transferencia",
                badgeBode: "Diagrama de Bode",
                badgeResonance: "Resonancia",
                circuitDiagram: "Esquema del Circuito",
                freqResponse: "Respuesta en Frecuencia",
                magLabel: "Magnitud (dB)",
                phaseLabel: "Fase (grados)",
                timeResponse: "Respuesta Temporal",
                tfTitle: "Función de Transferencia",
                governingEq: "Ecuación Diferencial",
                resonanceProps: "Propiedades de Resonancia",
                realWorld: "Impacto en el Mundo Real",
                series: "RLC Serie",
                parallel: "RLC Paralelo",
                rl: "Solo RL (1er Orden)",
                rc: "Solo RC (1er Orden)",
                step: "Entrada Escalón",
                impulse: "Entrada Impulso",
                sine: "Sinusoide",
                transient: "Respuesta Temporal",
                frequency: "Respuesta en Frecuencia"
            },
            pt: {
                title: "Equações de Circuito e Diagramas de Bode",
                subtitle: "Circuitos RLC, funções de transferência, ressonância e análise de resposta em frequência",
                config: "Configuração",
                topology: "Topologia do Circuito",
                inputSignal: "Sinal de Entrada",
                resistance: "Resistência R (Ω)",
                inductance: "Indutância L (H)",
                capacitance: "Capacitância C (F)",
                inputVoltage: "Tensão de Entrada (V)",
                analysisType: "Tipo de Análise",
                simulateBtn: "Simular e Analisar",
                badgeTF: "Função de Transferência",
                badgeBode: "Diagrama de Bode",
                badgeResonance: "Ressonância",
                circuitDiagram: "Esquema do Circuito",
                freqResponse: "Resposta em Frequência",
                magLabel: "Magnitude (dB)",
                phaseLabel: "Fase (graus)",
                timeResponse: "Resposta Temporal",
                tfTitle: "Função de Transferência",
                governingEq: "Equação Diferencial",
                resonanceProps: "Propriedades de Ressonância",
                realWorld: "Impacto no Mundo Real",
                series: "RLC Série",
                parallel: "RLC Paralelo",
                rl: "Apenas RL (1ª Ordem)",
                rc: "Apenas RC (1ª Ordem)",
                step: "Degrau",
                impulse: "Impulso",
                sine: "Senóide",
                transient: "Resposta Temporal",
                frequency: "Resposta em Frequência"
            },
            de: {
                title: "Schaltungsgleichungen & Bode-Diagramme",
                subtitle: "RLC-Schaltungen, Übertragungsfunktionen, Resonanz und Frequenzgangsanalyse",
                config: "Konfiguration",
                topology: "Schaltungstopologie",
                inputSignal: "Eingangssignal",
                resistance: "Widerstand R (Ω)",
                inductance: "Induktivität L (H)",
                capacitance: "Kapazität C (F)",
                inputVoltage: "Eingangsspannung (V)",
                analysisType: "Analysetyp",
                simulateBtn: "Simulieren & Analysieren",
                badgeTF: "Übertragungsfunktion",
                badgeBode: "Bode-Diagramm",
                badgeResonance: "Resonanz",
                circuitDiagram: "Schaltplan",
                freqResponse: "Frequenzgang",
                magLabel: "Betrag (dB)",
                phaseLabel: "Phase (Grad)",
                timeResponse: "Zeitbereichsantwort",
                tfTitle: "Übertragungsfunktion",
                governingEq: "Differentialgleichung",
                resonanceProps: "Resonanzeigenschaften",
                realWorld: "Reale Anwendungen",
                series: "RLC Serie",
                parallel: "RLC Parallel",
                rl: "Nur RL (1. Ordnung)",
                rc: "Nur RC (1. Ordnung)",
                step: "Sprungfunktion",
                impulse: "Impuls",
                sine: "Sinus",
                transient: "Zeitbereich",
                frequency: "Frequenzgang"
            },
            ua: {
                title: "Рівняння Кіл та Діаграми Боде",
                subtitle: "RLC кола, передавальні функції, резонанс та частотний аналіз",
                config: "Конфігурація",
                topology: "Топологія Кола",
                inputSignal: "Вхідний Сигнал",
                resistance: "Опір R (Ом)",
                inductance: "Індуктивність L (Гн)",
                capacitance: "Ємність C (Ф)",
                inputVoltage: "Вхідна Напруга (В)",
                analysisType: "Тип Аналізу",
                simulateBtn: "Симулювати та Аналізувати",
                badgeTF: "Передавальна Функція",
                badgeBode: "Діаграма Боде",
                badgeResonance: "Резонанс",
                circuitDiagram: "Схема Кола",
                freqResponse: "Частотна Характеристика",
                magLabel: "Амплітуда (дБ)",
                phaseLabel: "Фаза (градуси)",
                timeResponse: "Часова Характеристика",
                tfTitle: "Передавальна Функція",
                governingEq: "Диференціальне Рівняння",
                resonanceProps: "Резонансні Властивості",
                realWorld: "Практичне Застосування",
                series: "Послідовне RLC",
                parallel: "Паралельне RLC",
                rl: "Тільки RL",
                rc: "Тільки RC",
                step: "Сходинка",
                impulse: "Імпульс",
                sine: "Синусоїда",
                transient: "Часовий Аналіз",
                frequency: "Частотний Аналіз"
            },
            be: {
                title: "Ракнанні Ланцугоў і Дыяграмы Бодэ",
                subtitle: "RLC ланцугі, перадаткавыя функцыі, рэзананс і частотны аналіз",
                config: "Канфігурацыя",
                topology: "Тапалогія Ланцуга",
                inputSignal: "Уваходны Сігнал",
                resistance: "Супраціўленне R (Ом)",
                inductance: "Індуктыўнасць L (Гн)",
                capacitance: "Ёмістасць C (Ф)",
                inputVoltage: "Уваходнае Напружанне (В)",
                analysisType: "Тып Аналізу",
                simulateBtn: "Сімуляваць і Аналізаваць",
                badgeTF: "Перадаткавая Функцыя",
                badgeBode: "Дыяграма Бодэ",
                badgeResonance: "Рэзананс",
                circuitDiagram: "Схема Ланцуга",
                freqResponse: "Частотная Характарыстыка",
                magLabel: "Амплітуда (дБ)",
                phaseLabel: "Фаза (градусы)",
                timeResponse: "Часавая Характарыстыка",
                tfTitle: "Перадаткавая Функцыя",
                governingEq: "Дыферэнцыяльнае Раўнанне",
                resonanceProps: "Рэзанансныя Ўласцівасці",
                realWorld: "Практычнае Ужыванне",
                series: "Паслядоўнае RLC",
                parallel: "Паралельнае RLC",
                rl: "Толькі RL",
                rc: "Толькі RC",
                step: "Прыступка",
                impulse: "Імпульс",
                sine: "Сінусоіда",
                transient: "Часавы Аналіз",
                frequency: "Частотны Аналіз"
            }
        };

        const app = {
            magChart: null,
            phaseChart: null,
            transientChart: null,
            schematicCtx: null,
            state: {
                topology: 'series',
                inputType: 'step',
                R: 10,
                L: 0.1,
                C: 0.001,
                Vin: 10,
                analysis: 'transient'
            },
            lang: 'en',
            theme: 'light',
            initialized: false,

            // setTheme and setLang removed - handled by site.js

            // Calculate transfer function parameters
            getTransferFunction: () => {
                const R = app.state.R;
                const L = app.state.L;
                const C = app.state.C;
                const topology = app.state.topology;

                let tf = {};

                if (topology === 'series') {
                    // Series RLC: H(s) = 1 / (LCs^2 + RCs + 1)
                    tf.b = [1];
                    tf.a = [L * C, R * C, 1];
                    tf.wn = Math.sqrt(1 / (L * C)); // Natural frequency
                    tf.zeta = (R * C) / (2 * Math.sqrt(L / C)); // Damping ratio
                    tf.wd = tf.wn * Math.sqrt(Math.max(0, 1 - tf.zeta * tf.zeta)); // Damped frequency
                } else if (topology === 'parallel') {
                    // Parallel RLC: H(s) = R / (1 + RCs + LRs + LCs^2) simplified
                    tf.b = [1];
                    tf.a = [L * C, R * C, 1];
                    tf.wn = Math.sqrt(1 / (L * C));
                    tf.zeta = (R * C) / (2 * Math.sqrt(L / C));
                    tf.wd = tf.wn * Math.sqrt(Math.max(0, 1 - tf.zeta * tf.zeta));
                } else if (topology === 'rl') {
                    // RL: H(s) = 1 / (Ls + R)
                    tf.b = [1];
                    tf.a = [L, R];
                    tf.wn = R / L;
                    tf.zeta = 1;
                    tf.wd = 0;
                } else if (topology === 'rc') {
                    // RC: H(s) = 1 / (RCs + 1)
                    tf.b = [1];
                    tf.a = [R * C, 1];
                    tf.wn = 1 / (R * C);
                    tf.zeta = 1;
                    tf.wd = 0;
                }

                return tf;
            },

            // Evaluate transfer function at complex frequency s = jw
            evaluateTF: (tf, w) => {
                // Numerator B(s) = b[0]*s^m + ... (Here b is just [1], so B(s) = 1)
                // Denominator A(s) = a[0]*s^n + a[1]*s^(n-1) + ... + a[n]
                
                // Evaluate Polynomial P(s) at s = jw
                const evalPoly = (coeffs, w) => {
                    let real = 0;
                    let imag = 0;
                    const n = coeffs.length - 1;
                    
                    for (let i = 0; i <= n; i++) {
                        const power = n - i;
                        const coeff = coeffs[i];
                        // (jw)^k
                        // k=0: 1
                        // k=1: jw
                        // k=2: -w^2
                        // k=3: -jw^3
                        // k=4: w^4
                        const w_pow = Math.pow(w, power);
                        if (power % 4 === 0) real += coeff * w_pow;
                        else if (power % 4 === 1) imag += coeff * w_pow;
                        else if (power % 4 === 2) real -= coeff * w_pow;
                        else if (power % 4 === 3) imag -= coeff * w_pow;
                    }
                    return { real, imag };
                };

                const num = evalPoly(tf.b, w);
                const den = evalPoly(tf.a, w);

                // Complex division: num / den
                const den_mag_sq = den.real * den.real + den.imag * den.imag;
                const real = (num.real * den.real + num.imag * den.imag) / den_mag_sq;
                const imag = (num.imag * den.real - num.real * den.imag) / den_mag_sq;

                const magnitude = Math.sqrt(real * real + imag * imag);
                const phase = Math.atan2(imag, real) * 180 / Math.PI;

                return { magnitude, phase };
            },

            // Generate time-domain response
            generateTransientResponse: () => {
                const tf = app.getTransferFunction();
                const t_end = 1;
                const dt = 0.001;
                const t_points = Math.ceil(t_end / dt);
                const response = [];
                const time = [];

                const K = tf.b[0] / tf.a[tf.a.length - 1];

                for (let i = 0; i < t_points; i++) {
                    const t = i * dt;
                    time.push(t);

                    let y = K * app.state.Vin;
                    const zeta = tf.zeta;

                    if (zeta > 1) {
                        // Overdamped
                        const r1 = -tf.wn * (zeta - Math.sqrt(zeta * zeta - 1));
                        const r2 = -tf.wn * (zeta + Math.sqrt(zeta * zeta - 1));
                        y *= (1 + (r2 * Math.exp(r1 * t) - r1 * Math.exp(r2 * t)) / (r1 - r2));
                    } else if (zeta === 1) {
                        // Critically damped
                        y *= (1 - Math.exp(-tf.wn * t) * (1 + tf.wn * t));
                    } else {
                        // Underdamped
                        const decay = Math.exp(-zeta * tf.wn * t);
                        const phase = Math.atan2(tf.wd, zeta * tf.wn);
                        y *= (1 - decay * Math.cos(tf.wd * t - phase) / Math.cos(phase));
                    }

                    response.push(y);
                }

                return { time, response };
            },

            init: () => {
                const schematicCanvas = document.getElementById('schematicCanvas');
                app.schematicCtx = schematicCanvas ? schematicCanvas.getContext('2d') : null;

                // Tab handling for Topology
                document.querySelectorAll('#topologyTabs .tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('#topologyTabs .tab-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        app.state.topology = e.target.getAttribute('data-value');
                        app.updateFormDisplay();
                        app.update();
                    });
                });

                document.getElementById('inputType').addEventListener('change', (e) => {
                    app.state.inputType = e.target.value;
                    app.update();
                });

                document.getElementById('analysis').addEventListener('change', (e) => {
                    app.state.analysis = e.target.value;
                    app.update();
                });

                document.getElementById('sliderR').addEventListener('input', (e) => {
                    app.state.R = parseFloat(e.target.value);
                    document.getElementById('valR').textContent = app.state.R.toFixed(1);
                    app.update();
                });

                document.getElementById('sliderL').addEventListener('input', (e) => {
                    app.state.L = parseFloat(e.target.value);
                    document.getElementById('valL').textContent = app.state.L.toFixed(3);
                    app.update();
                });

                document.getElementById('sliderC').addEventListener('input', (e) => {
                    app.state.C = parseFloat(e.target.value);
                    document.getElementById('valC').textContent = app.state.C.toFixed(5);
                    app.update();
                });

                document.getElementById('sliderVin').addEventListener('input', (e) => {
                    app.state.Vin = parseFloat(e.target.value);
                    document.getElementById('valVin').textContent = app.state.Vin.toFixed(1);
                    app.update();
                });

                // Listen for site.js events
                window.addEventListener('themechange', (e) => {
                    app.theme = e.detail.theme;
                    if (app.initialized) {
                        app.updateChartTheme();
                        app.update();
                    }
                });
                
                window.addEventListener('langchange', (e) => {
                    app.lang = e.detail.lang;
                    app.updateTranslations();
                    if (app.initialized) app.update();
                });

                // Initial sync
                app.theme = document.documentElement.getAttribute('data-theme') || 'light';
                app.lang = document.documentElement.getAttribute('lang') || 'en';
                app.updateTranslations();

                app.updateFormDisplay();
                app.initCharts();
                app.initialized = true;
                app.update();
                if (window.lucide) lucide.createIcons();
            },

            updateTranslations: () => {
                const t = translations[app.lang];
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (t[key]) el.innerHTML = t[key];
                });
            },

            updateFormDisplay: () => {
                const t = app.state.topology;
                const showL = t === 'series' || t === 'parallel' || t === 'rl';
                const showC = t === 'series' || t === 'parallel' || t === 'rc';
                document.getElementById('groupL').classList.toggle('hidden', !showL);
                document.getElementById('groupC').classList.toggle('hidden', !showC);
            },

            hexToRgba: (hex, alpha) => {
                let r = 0, g = 0, b = 0;
                if (hex.startsWith('rgb')) return hex.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                if (hex.length === 4) {
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length === 7) {
                    r = parseInt(hex.slice(1, 3), 16);
                    g = parseInt(hex.slice(3, 5), 16);
                    b = parseInt(hex.slice(5, 7), 16);
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            },

            getVar: (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim(),

            getChartColors: () => {
                const primary = app.getVar('--primary');
                const accent = app.getVar('--accent');
                const success = app.getVar('--success');

                return {
                    text: app.getVar('--text-light'),
                    grid: app.getVar('--border'),
                    primary: primary,
                    primaryBg: app.hexToRgba(primary, 0.1),
                    secondary: accent,
                    secondaryBg: app.hexToRgba(accent, 0.6),
                    success: success,
                    successBg: app.hexToRgba(success, 0.1)
                };
            },

            updateChartTheme: () => {
                const colors = app.getChartColors();
                
                const updateChart = (chart) => {
                    if (!chart) return;
                    
                    if (chart.options.scales.x) {
                        chart.options.scales.x.title.color = colors.text;
                        chart.options.scales.x.grid.color = colors.grid;
                        chart.options.scales.x.ticks.color = colors.text;
                    }
                    if (chart.options.scales.y) {
                        chart.options.scales.y.title.color = colors.text;
                        chart.options.scales.y.grid.color = colors.grid;
                        chart.options.scales.y.ticks.color = colors.text;
                    }
                    
                    if (chart.options.plugins.legend) {
                        chart.options.plugins.legend.labels.color = colors.text;
                    }
                };

                updateChart(app.magChart);
                updateChart(app.phaseChart);
                updateChart(app.transientChart);

                if (app.magChart) {
                    app.magChart.data.datasets[0].borderColor = colors.primary;
                    app.magChart.data.datasets[0].backgroundColor = colors.primaryBg;
                    app.magChart.update();
                }
                if (app.phaseChart) {
                    app.phaseChart.data.datasets[0].borderColor = colors.secondary;
                    app.phaseChart.data.datasets[0].backgroundColor = colors.secondaryBg;
                    app.phaseChart.update();
                }
                if (app.transientChart) {
                    app.transientChart.data.datasets[0].borderColor = colors.success;
                    app.transientChart.data.datasets[0].backgroundColor = colors.successBg;
                    app.transientChart.update();
                }
            },

            initCharts: () => {
                if (!window.Chart) return;
                const magnitudeCanvas = document.getElementById('magnitudeChart');
                const phaseCanvas = document.getElementById('phaseChart');
                const transientCanvas = document.getElementById('transientChart');
                if (!magnitudeCanvas || !phaseCanvas || !transientCanvas) return;

                const colors = app.getChartColors();
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true, labels: { color: colors.text } } },
                    scales: {
                        x: {
                            title: { display: true, text: 'Frequency (Hz)', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        },
                        y: {
                            title: { display: true, text: 'Value', color: colors.text },
                            grid: { color: colors.grid },
                            ticks: { color: colors.text }
                        }
                    }
                };

                const magCtx = document.getElementById('magnitudeChart').getContext('2d');
                app.magChart = new Chart(magCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Magnitude', data: [], borderColor: colors.primary, backgroundColor: colors.primaryBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Frequency (Hz) - Log Scale', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: translations[app.lang]?.magLabel || 'Gain (dB)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });

                const phaseCtx = document.getElementById('phaseChart').getContext('2d');
                app.phaseChart = new Chart(phaseCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Phase', data: [], borderColor: colors.secondary, backgroundColor: colors.secondaryBg, borderWidth: 2, fill: false, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Frequency (Hz) - Log Scale', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: translations[app.lang]?.phaseLabel || 'Phase (degrees)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });

                const transCtx = document.getElementById('transientChart').getContext('2d');
                app.transientChart = new Chart(transCtx, {
                    type: 'line',
                    data: { labels: [], datasets: [{ label: 'Output', data: [], borderColor: colors.success, backgroundColor: colors.successBg, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 0 }] },
                    options: {
                        ...commonOptions,
                        scales: {
                            x: { type: 'linear', title: { display: true, text: 'Time (s)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } },
                            y: { title: { display: true, text: 'Output Voltage (V)', color: colors.text }, grid: { color: colors.grid }, ticks: { color: colors.text } }
                        }
                    }
                });
            },

            update: () => {
                app.drawSchematic();
                if (app.magChart && app.phaseChart) app.generateBodePlot();
                if (app.transientChart) app.generateTransientPlot();
                app.displayTransferFunction();
                app.displayEngineering();
            },

            drawSchematic: () => {
                const canvas = document.getElementById('schematicCanvas');
                const ctx = app.schematicCtx;
                if (!ctx) return;

                const w = canvas.clientWidth;
                const h = canvas.clientHeight;
                canvas.width = w;
                canvas.height = h;

                // Use CSS variables for colors
                const bgColor = app.getVar('--grid-bg');
                const strokeColor = app.getVar('--text-main');
                const primaryColor = app.getVar('--primary');
                const textColor = app.getVar('--text-light');

                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, w, h);

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.font = 'bold 14px Inter';
                ctx.fillStyle = primaryColor;

                // Helper functions for components
                const drawResistor = (x, y, len, vertical = false) => {
                    ctx.beginPath();
                    const seg = len / 6;
                    if (!vertical) {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + seg, y - 5);
                        ctx.lineTo(x + 2 * seg, y + 5);
                        ctx.lineTo(x + 3 * seg, y - 5);
                        ctx.lineTo(x + 4 * seg, y + 5);
                        ctx.lineTo(x + 5 * seg, y - 5);
                        ctx.lineTo(x + len, y);
                    } else {
                        ctx.moveTo(x, y);
                        ctx.lineTo(x - 5, y + seg);
                        ctx.lineTo(x + 5, y + 2 * seg);
                        ctx.lineTo(x - 5, y + 3 * seg);
                        ctx.lineTo(x + 5, y + 4 * seg);
                        ctx.lineTo(x - 5, y + 5 * seg);
                        ctx.lineTo(x, y + len);
                    }
                    ctx.stroke();
                };

                const drawInductor = (x, y, len, vertical = false) => {
                    ctx.beginPath();
                    const loops = 4;
                    const r = len / (loops * 2);
                    if (!vertical) {
                        for (let i = 0; i < loops; i++) {
                            ctx.arc(x + r + i * 2 * r, y, r, Math.PI, 0);
                        }
                    } else {
                        for (let i = 0; i < loops; i++) {
                            ctx.arc(x, y + r + i * 2 * r, r, 1.5 * Math.PI, 0.5 * Math.PI);
                        }
                    }
                    ctx.stroke();
                };

                const drawCapacitor = (x, y, size, vertical = false) => {
                    ctx.beginPath();
                    if (!vertical) {
                        ctx.moveTo(x, y - 10); ctx.lineTo(x, y + 10);
                        ctx.moveTo(x + 8, y - 10); ctx.lineTo(x + 8, y + 10);
                    } else {
                        ctx.moveTo(x - 10, y); ctx.lineTo(x + 10, y);
                        ctx.moveTo(x - 10, y + 8); ctx.lineTo(x + 10, y + 8);
                    }
                    ctx.stroke();
                };

                const drawSource = (x, y, r) => {
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.font = '16px Inter';
                    ctx.fillStyle = strokeColor;
                    ctx.fillText('~', x - 5, y + 5);
                };

                const t = app.state.topology;
                const cx = w / 2;
                const cy = h / 2;

                if (t === 'series') {
                    ctx.fillText(translations[app.lang]?.series || 'Series RLC Circuit', 20, 30);
                    
                    // Layout: Source Left, R Top, L Top, C Right (Loop)
                    // Let's do a simple rectangular loop
                    const lx = cx - 100;
                    const rx = cx + 100;
                    const ty = cy - 60;
                    const by = cy + 60;

                    // Wires
                    ctx.beginPath();
                    ctx.moveTo(lx, ty); ctx.lineTo(lx, by); // Left (Source)
                    ctx.moveTo(lx, ty); ctx.lineTo(rx, ty); // Top
                    ctx.moveTo(rx, ty); ctx.lineTo(rx, by); // Right
                    ctx.moveTo(rx, by); ctx.lineTo(lx, by); // Bottom
                    ctx.stroke();

                    // Clear gaps for components
                    ctx.clearRect(lx - 15, cy - 15, 30, 30); // Source
                    ctx.clearRect(cx - 60, ty - 10, 40, 20); // R
                    ctx.clearRect(cx + 20, ty - 10, 40, 20); // L
                    ctx.clearRect(rx - 10, cy - 10, 20, 20); // C

                    // Draw Components
                    drawSource(lx, cy, 15);
                    drawResistor(cx - 60, ty, 40);
                    drawInductor(cx + 20, ty, 40);
                    drawCapacitor(rx - 4, cy - 4, 20, true); // Vertical C

                    // Labels
                    ctx.fillStyle = primaryColor;
                    ctx.fillText('Vin', lx - 30, cy);
                    ctx.fillText('R', cx - 45, ty - 15);
                    ctx.fillText('L', cx + 35, ty - 15);
                    ctx.fillText('C', rx + 10, cy);

                } else if (t === 'parallel') {
                    ctx.fillText(translations[app.lang]?.parallel || 'Parallel RLC Circuit', 20, 30);
                    
                    const lx = cx - 120;
                    const rx = cx + 120;
                    const ty = cy - 60;
                    const by = cy + 60;
                    
                    // Wires
                    ctx.beginPath();
                    ctx.moveTo(lx, ty); ctx.lineTo(rx, ty); // Top Rail
                    ctx.moveTo(lx, by); ctx.lineTo(rx, by); // Bottom Rail
                    
                    // Vertical branches
                    ctx.moveTo(lx, ty); ctx.lineTo(lx, by); // Source
                    ctx.moveTo(cx - 40, ty); ctx.lineTo(cx - 40, by); // R
                    ctx.moveTo(cx + 40, ty); ctx.lineTo(cx + 40, by); // L
                    ctx.moveTo(rx, ty); ctx.lineTo(rx, by); // C
                    ctx.stroke();

                    // Clear gaps
                    ctx.clearRect(lx - 15, cy - 15, 30, 30); // Source
                    ctx.clearRect(cx - 50, cy - 20, 20, 40); // R
                    ctx.clearRect(cx + 30, cy - 20, 20, 40); // L
                    ctx.clearRect(rx - 10, cy - 10, 20, 20); // C

                    // Draw Components
                    drawSource(lx, cy, 15);
                    drawResistor(cx - 40, cy - 20, 40, true);
                    drawInductor(cx + 40, cy - 20, 40, true);
                    drawCapacitor(rx - 4, cy - 4, 20, true);

                    // Labels
                    ctx.fillStyle = primaryColor;
                    ctx.fillText('Vin', lx - 30, cy);
                    ctx.fillText('R', cx - 35, cy);
                    ctx.fillText('L', cx + 45, cy);
                    ctx.fillText('C', rx + 10, cy);

                } else if (t === 'rl') {
                    ctx.fillText(translations[app.lang]?.rl || 'RL Circuit', 20, 30);
                    
                    const lx = cx - 80;
                    const rx = cx + 80;
                    const ty = cy - 60;
                    const by = cy + 60;

                    ctx.beginPath();
                    ctx.moveTo(lx, ty); ctx.lineTo(lx, by);
                    ctx.moveTo(lx, ty); ctx.lineTo(rx, ty);
                    ctx.moveTo(rx, ty); ctx.lineTo(rx, by);
                    ctx.moveTo(rx, by); ctx.lineTo(lx, by);
                    ctx.stroke();

                    ctx.clearRect(lx - 15, cy - 15, 30, 30); // Source
                    ctx.clearRect(cx - 20, ty - 10, 40, 20); // R
                    ctx.clearRect(rx - 10, cy - 20, 20, 40); // L

                    drawSource(lx, cy, 15);
                    drawResistor(cx - 20, ty, 40);
                    drawInductor(rx, cy - 20, 40, true);

                    ctx.fillStyle = primaryColor;
                    ctx.fillText('Vin', lx - 30, cy);
                    ctx.fillText('R', cx - 5, ty - 15);
                    ctx.fillText('L', rx + 10, cy);

                } else if (t === 'rc') {
                    ctx.fillText(translations[app.lang]?.rc || 'RC Circuit', 20, 30);
                    
                    const lx = cx - 80;
                    const rx = cx + 80;
                    const ty = cy - 60;
                    const by = cy + 60;

                    ctx.beginPath();
                    ctx.moveTo(lx, ty); ctx.lineTo(lx, by);
                    ctx.moveTo(lx, ty); ctx.lineTo(rx, ty);
                    ctx.moveTo(rx, ty); ctx.lineTo(rx, by);
                    ctx.moveTo(rx, by); ctx.lineTo(lx, by);
                    ctx.stroke();

                    ctx.clearRect(lx - 15, cy - 15, 30, 30); // Source
                    ctx.clearRect(cx - 20, ty - 10, 40, 20); // R
                    ctx.clearRect(rx - 10, cy - 10, 20, 20); // C

                    drawSource(lx, cy, 15);
                    drawResistor(cx - 20, ty, 40);
                    drawCapacitor(rx - 4, cy - 4, 20, true);

                    ctx.fillStyle = primaryColor;
                    ctx.fillText('Vin', lx - 30, cy);
                    ctx.fillText('R', cx - 5, ty - 15);
                    ctx.fillText('C', rx + 10, cy);
                }

                ctx.font = '12px Inter';
                ctx.fillStyle = textColor;
                ctx.fillText(`R=${app.state.R.toFixed(1)}Ω`, 20, h - 80);
                if (t !== 'rc') ctx.fillText(`L=${app.state.L.toFixed(3)}H`, 20, h - 60);
                if (t !== 'rl') ctx.fillText(`C=${app.state.C.toFixed(5)}F`, 20, h - 40);
                ctx.fillText(`Vin=${app.state.Vin.toFixed(1)}V`, 20, h - 20);
            },

            generateBodePlot: () => {
                if (!app.magChart || !app.phaseChart) return;
                const tf = app.getTransferFunction();
                const freqs = [];
                const mags = [];
                const phases = [];

                for (let i = 0.1; i <= 1000; i *= 1.1) {
                    const w = 2 * Math.PI * i;
                    const response = app.evaluateTF(tf, w);
                    const magdB = 20 * Math.log10(Math.max(response.magnitude, 0.001));

                    freqs.push(i.toFixed(1));
                    mags.push(magdB);
                    phases.push(response.phase);
                }

                app.magChart.data.labels = freqs;
                app.magChart.data.datasets[0].data = mags;
                app.magChart.update();

                app.phaseChart.data.labels = freqs;
                app.phaseChart.data.datasets[0].data = phases;
                app.phaseChart.update();
            },

            generateTransientPlot: () => {
                if (!app.transientChart) return;
                const resp = app.generateTransientResponse();

                app.transientChart.data.labels = resp.time.map(t => t.toFixed(3));
                app.transientChart.data.datasets[0].data = resp.response;
                app.transientChart.update();
            },

            displayTransferFunction: () => {
                const tf = app.getTransferFunction();
                const t = app.state.topology;

                let tfStr = '';
                let deStr = '';

                if (t === 'series') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s² + ${app.state.R.toFixed(1)}s + ${(1 / app.state.C).toFixed(1)})`;
                    deStr = `L·d²V/dt² + R·dV/dt + (1/C)·V = Vin`;
                } else if (t === 'parallel') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s² + ${app.state.R.toFixed(1)}s + ${(1 / app.state.C).toFixed(1)})`;
                    deStr = `L·d²I/dt² + R·dI/dt + (1/C)·I = dVin/dt`;
                } else if (t === 'rl') {
                    tfStr = `H(s) = 1 / (${app.state.L.toFixed(3)}s + ${app.state.R.toFixed(1)})`;
                    deStr = `L·dI/dt + R·I = Vin`;
                } else if (t === 'rc') {
                    tfStr = `H(s) = 1 / (${app.state.R.toFixed(1)}·${app.state.C.toFixed(5)}·s + 1)`;
                    deStr = `RC·dV/dt + V = Vin`;
                }

                document.getElementById('tfDisplay').innerHTML = `<div class="formula"><strong>Transfer Function:</strong><br/>${tfStr}</div>`;
                document.getElementById('deDisplay').textContent = deStr;

                // Resonance info
                if (t === 'series' || t === 'parallel') {
                    const wn = tf.wn;
                    const fn = wn / (2 * Math.PI);
                    const Q = wn / (app.state.R / app.state.L);
                    const BW = wn / Q;

                    let resHTML = `
                        <div class="parameter-box">
                            <strong>Natural Frequency (f₀):</strong> ${fn.toFixed(2)} Hz
                        </div>
                        <div class="parameter-box">
                            <strong>Damping Ratio (ζ):</strong> ${tf.zeta.toFixed(3)}
                        </div>
                        <div class="parameter-box">
                            <strong>Quality Factor (Q):</strong> ${Q.toFixed(3)}
                        </div>
                        <div class="parameter-box">
                            <strong>Bandwidth:</strong> ${BW.toFixed(2)} rad/s
                        </div>
                    `;
                    document.getElementById('resonanceDisplay').innerHTML = resHTML;
                } else {
                    const tau = app.state.R * app.state.C || app.state.L / app.state.R;
                    document.getElementById('resonanceDisplay').innerHTML = `<div class="parameter-box"><strong>Time Constant (τ):</strong> ${tau.toFixed(4)} s</div>`;
                }
            },

            displayEngineering: () => {
                let html = '';
                const zeta = app.getTransferFunction().zeta;
                const t = app.state.topology;

                if (t === 'series') {
                    if (zeta > 1) {
                        html = '<strong>Overdamped Response:</strong> Slow response, no overshoot. Used in applications requiring smooth transitions (power supplies, audio filters).';
                    } else if (Math.abs(zeta - 1) < 0.01) {
                        html = '<strong>✓ Critically Damped:</strong> Fastest response without overshoot. Ideal for instrumentation and control systems.';
                    } else {
                        html = `<strong>🔄 Underdamped (Oscillatory):</strong> Overshoot ~${(100 * Math.exp(-Math.PI * zeta / Math.sqrt(1 - zeta * zeta))).toFixed(0)}%. Used in circuits requiring faster settling (switched-mode PSUs).`;
                    }
                } else if (t === 'rl' || t === 'rc') {
                    html = '<strong>1st Order Response:</strong> No resonance peak. Single time constant determines response speed. Common in filters and voltage regulators.';
                } else {
                    html = '<strong>Parallel RLC:</strong> Current-mode analysis. Used in impedance matching and tuned circuits.';
                }

                html += `<p style="margin-top: 12px; color: var(--text-main);">Current damping ratio ζ = ${zeta.toFixed(3)}. Adjust R, L, C sliders to modify circuit response.</p>`;

                document.getElementById('engineeringApp').innerHTML = html;
            }
        };

        window.onload = app.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>